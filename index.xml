<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Daryl&#39;s Blog</title>
    <link>https://siskinc.github.io/</link>
    <description>Recent content on Daryl&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 22 Oct 2021 16:23:08 +0800</lastBuildDate><atom:link href="https://siskinc.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Python Language Server 支持Pydantic</title>
      <link>https://siskinc.github.io/post/python-language-server-%E6%94%AF%E6%8C%81pydantic/</link>
      <pubDate>Fri, 22 Oct 2021 16:23:08 +0800</pubDate>
      
      <guid>https://siskinc.github.io/post/python-language-server-%E6%94%AF%E6%8C%81pydantic/</guid>
      <description>步骤  打开pydantic/main.py文件并且搜索ModelMetaclass定义，在ModelMetaclass类型定义，粘贴以下代码:  1 2 3 4 5 6 7 8  def __dataclass_transform__( *, eq_default: bool = True, order_default: bool = False, kw_only_default: bool = False, field_descriptors: Tuple[Union[type, Callable[..., Any]], ...] = (()), ) -&amp;gt; Callable[[_T], _T]: return lambda a: a   增加包装器在ModelMetaclass定义上:  1  @__dataclass_transform__(kw_only_default=True, field_descriptors=(Field, FieldInfo))   结果 修改前 修改后 参考文献 </description>
    </item>
    
    <item>
      <title>Python3在类的内部使用当前类作为类型提示</title>
      <link>https://siskinc.github.io/post/python3%E5%9C%A8%E7%B1%BB%E7%9A%84%E5%86%85%E9%83%A8%E4%BD%BF%E7%94%A8%E5%BD%93%E5%89%8D%E7%B1%BB%E4%BD%9C%E4%B8%BA%E7%B1%BB%E5%9E%8B%E6%8F%90%E7%A4%BA/</link>
      <pubDate>Thu, 19 Aug 2021 10:48:16 +0800</pubDate>
      
      <guid>https://siskinc.github.io/post/python3%E5%9C%A8%E7%B1%BB%E7%9A%84%E5%86%85%E9%83%A8%E4%BD%BF%E7%94%A8%E5%BD%93%E5%89%8D%E7%B1%BB%E4%BD%9C%E4%B8%BA%E7%B1%BB%E5%9E%8B%E6%8F%90%E7%A4%BA/</guid>
      <description>问题 在Python3中，例如：构建链表节点类，会有一个指向自身类型的指针，代码如下:
1 2 3 4 5  class ListNode(object): value: int nextNode: ListNode def merge(self, head: ListNode): pass   如果直接写成这样，代码提示器是无法识别到的
解决 Python 3.10以及以后的版本 已经支持该方式
Python 3.7+ 使用feature 1  from __future__ import annotations   Python 3.6以及更旧的版本 直接使用字符串的方式，例如:
1 2 3 4 5  class ListNode(object): value: int nextNode: &amp;#39;ListNode&amp;#39; def merge(self, head: &amp;#39;ListNode&amp;#39;): pass   参考资料 https://stackoverflow.com/questions/33533148/how-do-i-type-hint-a-method-with-the-type-of-the-enclosing-class</description>
    </item>
    
    <item>
      <title>Golang源码阅读 Bufio阅读</title>
      <link>https://siskinc.github.io/post/golang%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-bufio%E9%98%85%E8%AF%BB/</link>
      <pubDate>Thu, 22 Jul 2021 08:04:27 +0800</pubDate>
      
      <guid>https://siskinc.github.io/post/golang%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-bufio%E9%98%85%E8%AF%BB/</guid>
      <description>基本实现  实现带缓存的I/O模块 对io.Reader和io.Writer进行封装  实现带缓存 对字符的I/O操作友好    Reader(缓存输入)  实现了一个带缓存的io.Reader
 数据结构 1 2 3 4 5 6 7 8  type Reader struct { buf []byte // 缓存 	rd io.Reader // 被包装的io.Reader对象 	r, w int // buf切片上的索引，r代表读取的索引，w代表写入的索引 	err error // 用来存储该Reader在执行中遇到的error 	lastByte int // 已读取的最后一个字节; -1 代表无效 	lastRuneSize int // 已读取的最后一个rune; -1 代表无效 }   默认信息 1 2  const minReadBufferSize = 16 // buf最小长度为16字节 const maxConsecutiveEmptyReads = 100 // 一次读取，在连续100次没读取到会认为失败   关键代码逻辑 func (b *Reader) fill()  读取新的一个数据块，尽可能读满buf；只会读取成功读取一次，允许maxConsecutiveEmptyReads次读取失败，但是第一次读取成功后就不再读取，返回；</description>
    </item>
    
    <item>
      <title>当golang遇见工厂模式</title>
      <link>https://siskinc.github.io/post/%E5%BD%93golang%E9%81%87%E8%A7%81%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 07 Apr 2021 23:43:50 +0800</pubDate>
      
      <guid>https://siskinc.github.io/post/%E5%BD%93golang%E9%81%87%E8%A7%81%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>工厂模式  这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。
 介绍 意图  定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。
 主要解决  接口选择的问题。
 何时使用  我们明确地计划不同条件下创建不同实例时。
 如何解决  让其子类实现工厂接口，返回的也是一个抽象的产品。
 关键代码  创建过程在其子类执行。
 应用实例  您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 Hibernate 换数据库只需换方言和驱动就可以。  优点  一个调用者想创建一个对象，只要知道其名称就可以了。 扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 屏蔽产品的具体实现，调用者只关心产品的接口。  缺点  每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。  使用场景  日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 设计一个连接服务器的框架，需要三个协议，&amp;ldquo;POP3&amp;rdquo;、&amp;ldquo;IMAP&amp;rdquo;、&amp;ldquo;HTTP&amp;rdquo;，可以把这三个作为产品类，共同实现一个接口。  注意事项  作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。
 实现  现在有几个小孩：小明、小红、小白，现在要实现他们分别介绍自己的程序。我们将创建一个Child接口和实现Child接口的类。下一步是定义工厂类ChildFactory。
 定义Child接口 1 2 3  type Child interface { IntroduceYourself() }   定义小明、小红、小白三个Child实现类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  type Min struct { } func (Min) IntroduceYourself() { fmt.</description>
    </item>
    
    <item>
      <title>如何使用vscode远程调试Python</title>
      <link>https://siskinc.github.io/post/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8vscode%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95python/</link>
      <pubDate>Fri, 02 Apr 2021 08:51:31 +0800</pubDate>
      
      <guid>https://siskinc.github.io/post/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8vscode%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95python/</guid>
      <description>插件  SFTP Python  配置 sftp.json  用于同步本地代码和远端服务器代码
 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  { &amp;#34;name&amp;#34;: &amp;#34;remote sync&amp;#34;, &amp;#34;host&amp;#34;: &amp;#34;remote host&amp;#34;, &amp;#34;protocol&amp;#34;: &amp;#34;sftp&amp;#34;, &amp;#34;port&amp;#34;: 22, &amp;#34;username&amp;#34;: &amp;#34;username&amp;#34;, &amp;#34;password&amp;#34;: &amp;#34;password&amp;#34;, &amp;#34;remotePath&amp;#34;: &amp;#34;remote project path&amp;#34;, &amp;#34;uploadOnSave&amp;#34;: true, &amp;#34;ignore&amp;#34;: [ &amp;#34;.vscode&amp;#34;, &amp;#34;.git&amp;#34;, &amp;#34;.DS_Store&amp;#34;, &amp;#34;.idea&amp;#34;, &amp;#34;venv&amp;#34;, &amp;#34;__pycache__&amp;#34; ] }   tasks.json  用于一键启动远端程序
 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  { // See https://go.</description>
    </item>
    
    <item>
      <title>Python判断数字字符串</title>
      <link>https://siskinc.github.io/post/python%E5%88%A4%E6%96%AD%E6%95%B0%E5%AD%97%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Thu, 01 Apr 2021 08:37:46 +0800</pubDate>
      
      <guid>https://siskinc.github.io/post/python%E5%88%A4%E6%96%AD%E6%95%B0%E5%AD%97%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>今天遇到线上一个BUG，用户导入数据时，将某个字段填写一个负数会导致服务器报错，大概的代码如下:
1 2 3 4  if isinstance(obj, str) and obj.isdigit(): obj = int(obj) else: raise Exception(&amp;#34;fuck you&amp;#34;)   但是，负数并不能直接使用isdigit判断，看下截图： 所以，还需要做一些转换，满足这个需求:
1 2 3 4 5 6 7 8 9 10  def isdigit(num: str) -&amp;gt; bool: if not num: return False if num[0] == &amp;#39;-&amp;#39;: return num[1:].isdigit() return num.isdigit() if isinstance(num, str) and isdigit(num): num = int(num) else: raise Exception(&amp;#34;fuck you&amp;#34;)   </description>
    </item>
    
    <item>
      <title>Ubuntu16.04 笔记本合上盖子时不进入休眠</title>
      <link>https://siskinc.github.io/post/ubuntu16.04-%E7%AC%94%E8%AE%B0%E6%9C%AC%E5%90%88%E4%B8%8A%E7%9B%96%E5%AD%90%E6%97%B6%E4%B8%8D%E8%BF%9B%E5%85%A5%E4%BC%91%E7%9C%A0/</link>
      <pubDate>Fri, 22 Jan 2021 23:59:06 +0800</pubDate>
      
      <guid>https://siskinc.github.io/post/ubuntu16.04-%E7%AC%94%E8%AE%B0%E6%9C%AC%E5%90%88%E4%B8%8A%E7%9B%96%E5%AD%90%E6%97%B6%E4%B8%8D%E8%BF%9B%E5%85%A5%E4%BC%91%E7%9C%A0/</guid>
      <description>在笔记本上装ubuntu系统，也可以从事相关开发工作。但笔记本存在这样的情况，就是有时服务功能设好了，不需要操作了，但是希望机器一直开机提供服务，或者长期下载大文件。此时，为了省电，可将笔记本屏幕合上，静待其完成任务。 但是，在默认情况下，笔记本合上屏幕后，ubuntu系统会休眠，我试着用GUI改了一下设置，实践证明没有效果，还是直接修改配置文件来得快，方法如下： 修改 Login Manager的配置文件，/etc/systemd/logind.conf: 然后将其中的：
1  #HandleLidSwitch=suspend   改成：
1  HandleLidSwitch=ignore   然后重启服务：
1  service systemd-logind restart   或者直接重启
1  sudo shutdown -r now   即可使设置生效。</description>
    </item>
    
    <item>
      <title>go-redis批量(pipeline)拉取数据的操作</title>
      <link>https://siskinc.github.io/post/go-redis%E6%89%B9%E9%87%8Fpipeline%E6%8B%89%E5%8F%96%E6%95%B0%E6%8D%AE%E7%9A%84%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Mon, 09 Nov 2020 23:49:58 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/go-redis%E6%89%B9%E9%87%8Fpipeline%E6%8B%89%E5%8F%96%E6%95%B0%E6%8D%AE%E7%9A%84%E6%93%8D%E4%BD%9C/</guid>
      <description>主要没看见啥好的文档讲解，自己翻了翻源码，记录一下用法，见笑了
 原理 在调用pipeline每次append命令时，会返回一个对应的xxxxCmd对象指针，保留这个指针即可，在Exec()函数执行完成后，会将结果写入对应的对象内
demo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107  package main import ( &amp;#34;context&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;github.</description>
    </item>
    
    <item>
      <title>Python远程操作SSH</title>
      <link>https://siskinc.github.io/post/python%E8%BF%9C%E7%A8%8B%E6%93%8D%E4%BD%9Cssh/</link>
      <pubDate>Thu, 05 Nov 2020 13:59:29 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/python%E8%BF%9C%E7%A8%8B%E6%93%8D%E4%BD%9Cssh/</guid>
      <description>三方组件 paramiko
创建ssh 连接 1 2 3 4 5 6 7 8 9 10 11 12 13  def connect_ssh(host: str, port: int, username: str, password: str): ssh = paramiko.SSHClient() key = paramiko.AutoAddPolicy() ssh.set_missing_host_key_policy(key) ssh.connect(host, port, username, password, timeout=5) return ssh   执行命令 1 2 3 4 5 6 7 8 9  def execute(ssh: paramiko.SSHClient): stdin, stdout, stderr = ssh.exec_command(&amp;#39;command&amp;#39;) for line in stdout.readlines(): print(line)   </description>
    </item>
    
    <item>
      <title>幂次定律在Redis中的应用</title>
      <link>https://siskinc.github.io/post/%E5%B9%82%E6%AC%A1%E5%AE%9A%E5%BE%8B%E5%9C%A8redis%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</link>
      <pubDate>Sat, 12 Sep 2020 16:45:46 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/%E5%B9%82%E6%AC%A1%E5%AE%9A%E5%BE%8B%E5%9C%A8redis%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</guid>
      <description>幂次定律  如果某件事的发生频率和它的某个属性成幂关系，那么这个频率就可以称之为符合幂次定律。幂次定律的表现是少数几个事件的发生频率占了整个发生频率的大部分， 而其余的大多数事件只占整个发生频率的一个小部分。幂次定律
 Redis中的应用  在Redis中的跳表内容中有一个zslRandomLevel函数，返回一个随机的层级
 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  /* Returns a random level for the new skiplist node we are going to create. * The return value of this function is between 1 and ZSKIPLIST_MAXLEVEL * (both inclusive), with a powerlaw-alike distribution where higher * levels are less likely to be returned.</description>
    </item>
    
    <item>
      <title>redis lua script注意点</title>
      <link>https://siskinc.github.io/post/redis_lua_script%E6%B3%A8%E6%84%8F%E7%82%B9/</link>
      <pubDate>Sun, 16 Aug 2020 22:26:29 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/redis_lua_script%E6%B3%A8%E6%84%8F%E7%82%B9/</guid>
      <description>脚本死循环 Redis 的指令执行是个单线程，这个单线程还要执行来自客户端的 lua 脚本。如果 lua 脚本中来一个死循环，在脚本没有对 Redis 的内部数据状态进行修改时，可以使用script kill指令用于动态杀死一个执行时间超时的 lua 脚本。因为 Redis 不允许 script kill 破坏脚本执行的原子性。比如脚本内部使用了 redis.call(&amp;ldquo;set&amp;rdquo;, key, value) 修改了内部的数据，那么 script kill 执行时服务器会返回错误。
Script Kill 的原理 lua 脚本引擎功能太强大了，它提供了各式各样的钩子函数，它允许在内部虚拟机执行指令时运行钩子代码。比如每执行 N 条指令执行一次某个钩子函数，Redis 正是使用了这个钩子函数。

1 2 3 4 5 6 7 8 9 10 11 12 13  void evalGenericCommand(client *c, int evalsha) { ... // lua引擎每执行10w条指令，执行一次钩子函数 luaMaskCountHook  lua_sethook(lua,luaMaskCountHook,LUA_MASKCOUNT,100000); ... }   </description>
    </item>
    
    <item>
      <title>Golang map数据结构接受json中的uint64数据</title>
      <link>https://siskinc.github.io/post/golang_map%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%8E%A5%E5%8F%97json%E4%B8%AD%E7%9A%84uint64%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Wed, 27 May 2020 13:16:11 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/golang_map%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%8E%A5%E5%8F%97json%E4%B8%AD%E7%9A%84uint64%E6%95%B0%E6%8D%AE/</guid>
      <description>例如有一个json数据：
1 2 3 4 5 6 7 8 9  { &amp;#34;name&amp;#34;: &amp;#34;小明&amp;#34;, &amp;#34;money&amp;#34;: 1111111111111111111 }   但是小明很有钱，他的钱用int64是存储不下来的，如果我们用一个结构体来接受数据就很简单，例如：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  package main import ( &amp;#34;encoding/json&amp;#34; &amp;#34;fmt&amp;#34; ) type Info struct { Name string `json:&amp;#34;name&amp;#34;` Money uint64 `json:&amp;#34;money&amp;#34;` } func main() { info := &amp;amp;Info{} json.</description>
    </item>
    
    <item>
      <title>Redis源码阅读之quicklist</title>
      <link>https://siskinc.github.io/post/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8Bquicklist/</link>
      <pubDate>Thu, 21 May 2020 23:37:05 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8Bquicklist/</guid>
      <description>数据结构 quicklistNode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  /* quicklistNode is a 32 byte struct describing a ziplist for a quicklist. * We use bit fields keep the quicklistNode at 32 bytes. * count: 16 bits, max 65536 (max zl bytes is 65k, so max count actually &amp;lt; 32k).</description>
    </item>
    
    <item>
      <title>Redis字典扩张算法</title>
      <link>https://siskinc.github.io/post/redis%E5%AD%97%E5%85%B8%E6%89%A9%E5%BC%A0%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 16 May 2020 00:05:19 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/redis%E5%AD%97%E5%85%B8%E6%89%A9%E5%BC%A0%E7%AE%97%E6%B3%95/</guid>
      <description>源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  /* This is the initial size of every hash table */ #define DICT_HT_INITIAL_SIZE 4  /* Our hash table capability is a power of two */ static unsigned long _dictNextPower(unsigned long size) { unsigned long i = DICT_HT_INITIAL_SIZE; if (size &amp;gt;= LONG_MAX) return LONG_MAX + 1LU; while(1) { if (i &amp;gt;= size) return i; i *= 2; } }   结论  Redis的dict会从4开始扩张，最大到达LONG_MAX + 1LU</description>
    </item>
    
    <item>
      <title>Golang源码阅读之map</title>
      <link>https://siskinc.github.io/post/golang%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8Bmap/</link>
      <pubDate>Fri, 15 May 2020 23:33:35 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/golang%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8Bmap/</guid>
      <description>源码地址:src/runtime/map.go
描述   Map 是一种无序的键值对的集合。Map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值。
  Map 是一种集合，所以我们可以像迭代数组和切片那样迭代它。不过，Map 是无序的，我们无法决定它的返回顺序，这是因为 Map 是使用 hash 表来实现的。
  </description>
    </item>
    
    <item>
      <title>Redis源码阅读之动态字符串</title>
      <link>https://siskinc.github.io/post/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8B%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Sun, 10 May 2020 11:07:16 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8B%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>数据结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65  typedef char *sds; /* Note: sdshdr5 is never used, we just access the flags byte directly.</description>
    </item>
    
    <item>
      <title>HTTP 与 HTTPS 的区别</title>
      <link>https://siskinc.github.io/post/http_%E4%B8%8E_https_%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sat, 25 Apr 2020 22:00:23 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/http_%E4%B8%8E_https_%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息，HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。
为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。
基本概念 HTTP  是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。
 HTTPS  是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。
 主要作用   建立一个信息安全通道，来保证数据传输的安全
  另一种就是确认网站的真实性。
  HTTP与HTTPS区别   https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
  http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
  http和https使用的是完全不同的连接方式，默认端口也不一样，前者是80，后者是443。
  http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。
  SSL加密方式 SSL协议既用到了对称加密也用到了非对称加密(公钥加密)，在建立传输链路时，SSL首先对对称加密的密钥使用公钥进行非对称加密，链路建立好之后，SSL对传输内容使用对称加密。
对称加密  速度高，可加密内容较大，用来加密会话过程中的消息
 公钥加密  加密速度较慢，但能提供更好的身份认证技术，用来加密对称加密的密钥
 HTTPS工作原理 单向验证与双向验证的区别 单向验证： 指客户端验证服务器端证书，服务器并不需要验证客户端证书。
双向验证：指客户端验证服务器端证书，而服务器也需要通过CA的公钥证书来验证客户端证书。
单向认证 Https在建立Socket连接之前，需要进行握手，具体过程如下：

  客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息;
  服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书;
  客户端使用服务端返回的信息验证服务器的合法性，包括：
  证书是否过期;
  发行服务器证书的CA是否可靠;(通过查询浏览器或本机内的CA证书)
  返回的公钥是否能正确解开返回证书中的数字签名;（通过使用本机或浏览器内置的CA公钥进行解密）</description>
    </item>
    
    <item>
      <title>Redis源码阅读之内存分配</title>
      <link>https://siskinc.github.io/post/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8B%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</link>
      <pubDate>Wed, 22 Apr 2020 23:01:09 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8B%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</guid>
      <description>zmalloc是什么  zmalloc是redis内存分配的基本操作，相当于包了一层malloc的操作，分配出来的内存不只是裸露的
 API 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  void *zmalloc(size_t size); void *zcalloc(size_t size); void *zrealloc(void *ptr, size_t size); void zfree(void *ptr); char *zstrdup(const char *s); size_t zmalloc_used_memory(void); void zmalloc_set_oom_handler(void (*oom_handler)(size_t)); size_t zmalloc_get_rss(void); int zmalloc_get_allocator_info(size_t *allocated, size_t *active, size_t *resident); void set_jemalloc_bg_thread(int enable); int jemalloc_purge(); size_t zmalloc_get_private_dirty(long pid); size_t zmalloc_get_smap_bytes_by_field(char *field, long pid); size_t zmalloc_get_memory_size(void); void zlibc_free(void *ptr);   内存分配zmalloc，zcalloc 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  void *zmalloc(size_t size) { void *ptr = malloc(size+PREFIX_SIZE); if (!</description>
    </item>
    
    <item>
      <title>Redis源码阅读之字典（二）——Rehash</title>
      <link>https://siskinc.github.io/post/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8B%E5%AD%97%E5%85%B8%E4%BA%8Crehash/</link>
      <pubDate>Tue, 21 Apr 2020 23:58:01 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8B%E5%AD%97%E5%85%B8%E4%BA%8Crehash/</guid>
      <description>历史文章 Redis源码阅读之字典（一）
Redis Rehash是什么？  在我们日常使用redis的过程中，随着key不断的增加，dict的size也在不断的增加，当dict.used == dict.size或者used*100/size &amp;lt; HASHTABLE_MIN_FILL,HASHTABLE_MIN_FILL一般为10，也就是说，要么容量不够，要么容量使用率小于10%了，就会调用dictExpand进行重新分配内存，这个时候就会触发rehash了。但是rehash不行一次性就操作完成了，试想一下，如果一个dict里面含有数百万的key，rehash一次可能会很久，就可能造成服务假死的情况。所以rehashing是一个长时间的过程，每一次可能只进行几个key的迁移。
 哪些操作会触发rehashing的step dictRehashMilliseconds  redis server的定时任务会去执行dictRehashMilliseconds，但是都是传入的ms==1，主要是rehashing一下redis的dict和expired相关的键
 dictAddRaw  在给dict增加key的时候，新增的key会直接放入dict.ht[1]中
 dictGenericDelete  删除key时
 dictFind  查找key
 dictGetRandomKey 和 dictGetSomeKeys  获取随机key
 dictScan  遍历dict
 每次rehash的过程 源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107  /* Performs N steps of incremental rehashing.</description>
    </item>
    
    <item>
      <title>Redis源码阅读-dict</title>
      <link>https://siskinc.github.io/post/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-dict/</link>
      <pubDate>Tue, 21 Apr 2020 23:23:41 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-dict/</guid>
      <description>数据结构 字典的基本单元——dictEntry 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  typedef struct dictEntry { void *key; union { void *val; uint64_t u64; int64_t s64; double d; } v; struct dictEntry *next; } dictEntry;   dictEntry是Redis中的哈希表数据接口的基本单元，有一个指向key的指针，还有一个联合体v，代表的是字典的值，它可以是一个数字（浮点或者有符号整型或者无符号整型），还有一个next字段指向下一个dictEntry的指针。说明了一个问题，dictEntry其实是一个链表节点。
哈希表——dictht 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  /* This is our hash table structure.</description>
    </item>
    
    <item>
      <title>Redis源码阅读之字典（一）</title>
      <link>https://siskinc.github.io/post/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8B%E5%AD%97%E5%85%B8%E4%B8%80/</link>
      <pubDate>Tue, 21 Apr 2020 23:23:41 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8B%E5%AD%97%E5%85%B8%E4%B8%80/</guid>
      <description>数据结构 字典的基本单元——dictEntry 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  typedef struct dictEntry { void *key; union { void *val; uint64_t u64; int64_t s64; double d; } v; struct dictEntry *next; } dictEntry;   dictEntry是Redis中的哈希表数据接口的基本单元，有一个指向key的指针，还有一个联合体v，代表的是字典的值，它可以是一个数字（浮点或者有符号整型或者无符号整型），还有一个next字段指向下一个dictEntry的指针。说明了一个问题，dictEntry其实是一个链表节点。
哈希表——dictht 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  /* This is our hash table structure.</description>
    </item>
    
    <item>
      <title>Centos下，源码安装Python的h3包</title>
      <link>https://siskinc.github.io/post/centos%E4%B8%8B%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85python%E7%9A%84h3%E5%8C%85/</link>
      <pubDate>Mon, 06 Apr 2020 17:36:42 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/centos%E4%B8%8B%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85python%E7%9A%84h3%E5%8C%85/</guid>
      <description>公司的渣渣网速，在服务器上pip install h3的时候老是git clone 失败，不得已，只能手动安装h3的包，下面就是我安装h3包的全部过程。
 检查cmake版本 1 2 3  cmake --version   如果版本显示是3.1以上就算OK的，但是在centos下面使用yum安装的默认就是2.8的版本，所以需要自己手动安装一下，如何安装我就不说了，传送门给你们：Centos7安装高版本Cmake
下载文件  自己下载对于的master压缩包
   https://github.com/uber/h3
  https://github.com/uber/h3-py
  解压文件 1 2 3 4 5  unzip h3-master.zip unzip h3-py-master.zip   修改.install.sh文件 在解压后的h3-py-master文件夹中有一个.install.sh
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101  #!</description>
    </item>
    
    <item>
      <title>Golang重复对一个slice进行append造成数据错误</title>
      <link>https://siskinc.github.io/post/golang%E9%87%8D%E5%A4%8D%E5%AF%B9%E4%B8%80%E4%B8%AAslice%E8%BF%9B%E8%A1%8Cappend%E9%80%A0%E6%88%90%E6%95%B0%E6%8D%AE%E9%94%99%E8%AF%AF/</link>
      <pubDate>Sat, 04 Apr 2020 20:06:21 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/golang%E9%87%8D%E5%A4%8D%E5%AF%B9%E4%B8%80%E4%B8%AAslice%E8%BF%9B%E8%A1%8Cappend%E9%80%A0%E6%88%90%E6%95%B0%E6%8D%AE%E9%94%99%E8%AF%AF/</guid>
      <description>slice的属性   切片（slice）是建立在数组之上的更方便，更灵活，更强大的数据结构。切片并不存储任何元素而只是对现有数组的引用。
  切片的长度是指切片中元素的个数。切片的容量是指从切片的起始元素开始到其底层数组中的最后一个元素的个数。
  那么问题来了，几个不同的切片指向同一个数组，如果数组的值被改变会出现什么神奇的操作？
问题实例 slice的cap是怎么增长的   参考文章:How does Go slice capacity change on append? [duplicate]
  有兴趣也可以看看golang的源码实现,在$GOPATH/src/runtime/slice.go
  slice的结构 1 2 3 4 5 6 7 8 9 10 11  type slice struct { array unsafe.Pointer len int cap int }   多次append造成的数据错误 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  package main import &amp;#34;fmt&amp;#34; func main() { temp := []int{} temp = append(temp, 1) printSlice(&amp;#34;temp&amp;#34;, temp) temp = append(temp, 2) printSlice(&amp;#34;temp&amp;#34;, temp) temp = append(temp, 3) // temp := []int{1, 2, 3}  printSlice(&amp;#34;temp&amp;#34;, temp) temp2 := append(temp, 4) printSlice(&amp;#34;temp2&amp;#34;, temp2) temp4 := append(temp, 5, 6) printSlice(&amp;#34;temp4&amp;#34;, temp4) temp3 := append(temp, 5) printSlice(&amp;#34;temp3&amp;#34;, temp3) printSlice(&amp;#34;temp2&amp;#34;, temp2) } func printSlice(valName string, s []int) { fmt.</description>
    </item>
    
    <item>
      <title>乐观锁（CAS）</title>
      <link>https://siskinc.github.io/post/%E4%B9%90%E8%A7%82%E9%94%81cas/</link>
      <pubDate>Sat, 14 Mar 2020 17:33:17 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/%E4%B9%90%E8%A7%82%E9%94%81cas/</guid>
      <description>什么是CAS   CAS(compare and swap) 比较并替换，比较和替换是线程并发算法时用到的一种技术
  CAS是原子操作，保证并发安全，而不是保证并发同步
  CAS是CPU的一个指令
  CAS是非阻塞的、轻量级的乐观锁
  为什么说CAS是乐观锁  乐观锁，严格来说并不是锁，通过原子性来保证数据的同步，比如说数据库的乐观锁，通过版本控制来实现等，所以CAS不会保证线程同步。乐观的认为在数据更新期间没有其他线程影响
 CAS原理  CAS(compare and swap) 比较并替换，就是将内存值更新为需要的值，但是有个条件，内存值必须与期望值相同。举个例子，期望值 E、内存值M、更新值U，当E == M的时候将M更新为U。
 CAS优缺点   优点
 非阻塞的轻量级的乐观锁，通过CPU指令实现，在资源竞争不激烈的情况下性能高，相比synchronized重量锁，synchronized会进行比较复杂的加锁，解锁和唤醒操作。    缺点
  ABA问题 线程C、D,线程D将A修改为B后又修改为A,此时C线程以为A没有改变过，java的原子类AtomicStampedReference，通过控制变量值的版本来保证CAS的正确性。
  自旋时间过长，消耗CPU资源， 如果资源竞争激烈，多线程自旋长时间消耗资源。
    CAS例子 不加锁 代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  package main import &amp;#34;fmt&amp;#34; var p uint64 var end = make(chan struct{}, 2) func changeP() { for i := 0; i &amp;lt; 100000; i++ { p++ } end &amp;lt;- struct{}{} } func main() { go changeP() go changeP() &amp;lt;-end &amp;lt;-end fmt.</description>
    </item>
    
    <item>
      <title>Ubuntu 18.04换国内源</title>
      <link>https://siskinc.github.io/post/ubuntu_18.04%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90/</link>
      <pubDate>Fri, 28 Feb 2020 16:54:07 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/ubuntu_18.04%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90/</guid>
      <description>国内有很多Ubuntu的镜像源，例如阿里、网易、清华、中科大。
我们这里以阿里云的源为例展示如何修改Ubuntu 18.04里面默认的源。
编辑/etc/apt/sources.list文件：
deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse中科大源 deb https://mirrors.</description>
    </item>
    
    <item>
      <title>Windows下如何使用pip安装Uber H3</title>
      <link>https://siskinc.github.io/post/windows%E4%B8%8B%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8pip%E5%AE%89%E8%A3%85uber_h3/</link>
      <pubDate>Wed, 26 Feb 2020 17:21:02 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/windows%E4%B8%8B%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8pip%E5%AE%89%E8%A3%85uber_h3/</guid>
      <description>最近项目中会用到uber h3，而我写一个小工具或者去验证一些思路的时候常常会使用Python来着，方便嘛！而Uber H3是C写的，只是为Python提供了拓展，所以需要安装Vs14。这个需要自己提前安装好。
在使用pip安装时直接报错了！
大概的报错内容就是需要cmake，bash等东西，cmake好解决，自己下载到本地，放到环境变量里面就行，bash可以使用git bash来代替，所以只能跟Power shell暂时说拜拜，使用Git Bash来安装H3。Ok， 你运行pip install h3就会看见如下界面</description>
    </item>
    
    <item>
      <title>Nexus 5X API 29 x86模拟器无法联网，无法打开chrome</title>
      <link>https://siskinc.github.io/post/nexus_5x_api_29_x86%E6%A8%A1%E6%8B%9F%E5%99%A8%E6%97%A0%E6%B3%95%E8%81%94%E7%BD%91%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80chrome/</link>
      <pubDate>Wed, 05 Feb 2020 21:40:19 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/nexus_5x_api_29_x86%E6%A8%A1%E6%8B%9F%E5%99%A8%E6%97%A0%E6%B3%95%E8%81%94%E7%BD%91%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80chrome/</guid>
      <description>  在Android Studio中打开AVD Manager
  点击Create Virtual Device&amp;hellip;按钮
  
 无法联网的原因没找到，但是无法打开chrome视乎是应为用了Play Store套件，选择没有Play Store的虚拟机即可，亲测有效
 </description>
    </item>
    
    <item>
      <title>远程办公的优劣</title>
      <link>https://siskinc.github.io/post/%E8%BF%9C%E7%A8%8B%E5%8A%9E%E5%85%AC%E7%9A%84%E4%BC%98%E5%8A%A3/</link>
      <pubDate>Mon, 03 Feb 2020 22:19:09 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/%E8%BF%9C%E7%A8%8B%E5%8A%9E%E5%85%AC%E7%9A%84%E4%BC%98%E5%8A%A3/</guid>
      <description>优势   起床就能工作，累了就能马上躺下休息。
  事儿干完了能够开心的摸鱼，想看书看书，想刷题刷题。
  遇到烦心事可以破口大骂不怕人听见，哈哈。
  劣势   如果自制力不够，无法专心工作，容易摸鱼。
  沟通困难，可能你想找的人也找不到。
  没有工作氛围，没有工作节奏，等12点的时候，你发现厨房里面没饭吃。
  生活容易被打扰，有些人会更加容易把工作和生活混在一起，那你的休息时间可就没了！
  </description>
    </item>
    
    <item>
      <title>xshell过期了怎么办，如何破解xshell</title>
      <link>https://siskinc.github.io/post/xshell%E8%BF%87%E6%9C%9F%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%E5%A6%82%E4%BD%95%E7%A0%B4%E8%A7%A3xshell/</link>
      <pubDate>Wed, 25 Dec 2019 20:35:41 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/xshell%E8%BF%87%E6%9C%9F%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%E5%A6%82%E4%BD%95%E7%A0%B4%E8%A7%A3xshell/</guid>
      <description>  卸载xshell
  删除xshell注册表
  打开运行框（快捷键WIN+R）,输入regedit.exe
  删除计算机\HKEY_CURRENT_USER\Software\Netscape目录
    重新安装xshell
  </description>
    </item>
    
    <item>
      <title>golang scan rows to []string，golang使用mysql，将结果写入到string列表中</title>
      <link>https://siskinc.github.io/post/golang_scan_rows_to_stringgolang%E4%BD%BF%E7%94%A8mysql%E5%B0%86%E7%BB%93%E6%9E%9C%E5%86%99%E5%85%A5%E5%88%B0string%E5%88%97%E8%A1%A8%E4%B8%AD/</link>
      <pubDate>Tue, 17 Dec 2019 19:36:31 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/golang_scan_rows_to_stringgolang%E4%BD%BF%E7%94%A8mysql%E5%B0%86%E7%BB%93%E6%9E%9C%E5%86%99%E5%85%A5%E5%88%B0string%E5%88%97%E8%A1%A8%E4%B8%AD/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  rows, err := db.Query(sqlStr) if err != nil { return } for rows.Next() { result := make([]string, len(readerResult.Columns)) pointers := make([]interface{}, len(result)) for i := range pointers { pointers[i] = &amp;amp;result[i] } err := rows.Scan(pointers...) if err != nil { logrus.</description>
    </item>
    
    <item>
      <title>nohup不输出日志信息的方法</title>
      <link>https://siskinc.github.io/post/nohup%E4%B8%8D%E8%BE%93%E5%87%BA%E6%97%A5%E5%BF%97%E4%BF%A1%E6%81%AF%E7%9A%84%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sun, 15 Dec 2019 09:45:40 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/nohup%E4%B8%8D%E8%BE%93%E5%87%BA%E6%97%A5%E5%BF%97%E4%BF%A1%E6%81%AF%E7%9A%84%E6%96%B9%E6%B3%95/</guid>
      <description>只输出错误信息到日志文件 1 2 3  nohup ./program &amp;gt; /dev/null 2 &amp;gt; log &amp;amp;   什么信息也不要 1 2 3  nohup ./program &amp;gt;/dev/null 2&amp;gt;&amp;amp;1 &amp;amp;   </description>
    </item>
    
    <item>
      <title>git使用ssh自动替代https</title>
      <link>https://siskinc.github.io/post/git%E4%BD%BF%E7%94%A8ssh%E8%87%AA%E5%8A%A8%E6%9B%BF%E4%BB%A3https/</link>
      <pubDate>Thu, 12 Dec 2019 22:40:31 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/git%E4%BD%BF%E7%94%A8ssh%E8%87%AA%E5%8A%A8%E6%9B%BF%E4%BB%A3https/</guid>
      <description> 在使用go mod的时候，并且在一些私有的仓库，例如公司的代码库中，经常会需要输入密码，我们可以现在公司的代码库中设置好ssh密钥
 本地执行git命令: 1 2 3 4 5  git config --global url.&amp;#34;git@github.com:&amp;#34;.insteadOf &amp;#34;https://github.com/&amp;#34; git config --global url.&amp;#34;git@git.company.com:&amp;#34;.insteadOf &amp;#34;https://git.company.com/&amp;#34;    company.com换成你自己公司的地址即可。
  而对于 golang.org 上的代码，在这一阶段，会从 https://go.googlesource.com 获取代码，不过庆幸的是，这些代码都在 github 上有镜像，我们可以替换一下： 1 2 3  git config --global url.&amp;#34;git@github.com:golang/&amp;#34;.insteadOf &amp;#34;https://go.googlesource.com/&amp;#34;   </description>
    </item>
    
    <item>
      <title>Golang交叉编译</title>
      <link>https://siskinc.github.io/post/golang%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/</link>
      <pubDate>Thu, 12 Dec 2019 09:31:27 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/golang%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/</guid>
      <description>Mac 下编译 Linux 和 Windows 64位可执行程序 1 2 3 4 5  CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build main.go CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build main.go   Linux 下编译 Mac 和 Windows 64位可执行程序 1 2 3 4 5  CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build main.go CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build main.go   Windows 下编译 Mac 和 Linux 64位可执行程序(cmd下) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  SET CGO_ENABLED=0 SET GOOS=darwin SET GOARCH=amd64 go build main.</description>
    </item>
    
    <item>
      <title>k8s服务直接挂掉的原因</title>
      <link>https://siskinc.github.io/post/k8s%E6%9C%8D%E5%8A%A1%E7%9B%B4%E6%8E%A5%E6%8C%82%E6%8E%89%E7%9A%84%E5%8E%9F%E5%9B%A0/</link>
      <pubDate>Thu, 12 Dec 2019 09:28:32 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/k8s%E6%9C%8D%E5%8A%A1%E7%9B%B4%E6%8E%A5%E6%8C%82%E6%8E%89%E7%9A%84%E5%8E%9F%E5%9B%A0/</guid>
      <description> 首先要确定一点，在本地环境，配置一模一样，程序跑起来是正常的，但是一放到k8s就会直接挂掉，目前收集到两种原因
   内存不够，OOM
  CPU不够
  </description>
    </item>
    
    <item>
      <title>gorm软删除和唯一键冲突的问题</title>
      <link>https://siskinc.github.io/post/gorm%E8%BD%AF%E5%88%A0%E9%99%A4%E5%92%8C%E5%94%AF%E4%B8%80%E9%94%AE%E5%86%B2%E7%AA%81%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 09 Dec 2019 21:27:01 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/gorm%E8%BD%AF%E5%88%A0%E9%99%A4%E5%92%8C%E5%94%AF%E4%B8%80%E9%94%AE%E5%86%B2%E7%AA%81%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description> 如果直接使用gorm.Model嵌入到自己的model中，就无法对DeletedAt进行附加的操作，最简单的方式就是将gorm.Model的内容拷贝出来，将DeletedAt加入到自己的unique_index中  </description>
    </item>
    
    <item>
      <title>wordpress,docker,插件升级</title>
      <link>https://siskinc.github.io/post/wordpressdocker%E6%8F%92%E4%BB%B6%E5%8D%87%E7%BA%A7/</link>
      <pubDate>Fri, 06 Dec 2019 16:53:30 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/wordpressdocker%E6%8F%92%E4%BB%B6%E5%8D%87%E7%BA%A7/</guid>
      <description>  wp-config.php最后一行添加define(&#39;FS_METHOD&#39;, &amp;quot;direct&amp;quot;);
  设置文件权限chown -R www-data:www-data ./
  </description>
    </item>
    
    <item>
      <title>Run jQuery in Chrome Console</title>
      <link>https://siskinc.github.io/post/run_jquery_in_chrome_console/</link>
      <pubDate>Thu, 28 Nov 2019 00:57:49 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/run_jquery_in_chrome_console/</guid>
      <description>1 2 3  var jqry = document.createElement(&amp;#39;script&amp;#39;); jqry.src = &amp;#34;https://code.jquery.com/jquery-3.3.1.min.js&amp;#34;; document.getElementsByTagName(&amp;#39;head&amp;#39;)[0].appendChild(jqry); jQuery.noConflict();   </description>
    </item>
    
    <item>
      <title>golang http.client 的 Connection reset by peer 问题</title>
      <link>https://siskinc.github.io/post/golang_http.client_%E7%9A%84_connection_reset_by_peer_%E9%97%AE%E9%A2%98/</link>
      <pubDate>Thu, 28 Nov 2019 00:28:26 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/golang_http.client_%E7%9A%84_connection_reset_by_peer_%E9%97%AE%E9%A2%98/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  func main() { req, err := http.NewRequest(&amp;#34;GET&amp;#34;, &amp;#34;http://www.baidu.com&amp;#34;,nil ) if err != nil { log.Errorf(&amp;#34;&amp;#34;) } req.Close = true resp, err := http.Client.Do(req) }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  func main() { req, err := http.NewRequest(&amp;#34;GET&amp;#34;, &amp;#34;http://www.baidu.com&amp;#34;,nil ) if err !</description>
    </item>
    
    <item>
      <title>记一次kafka-go使用踩坑（多个partition只会写入一个partition）</title>
      <link>https://siskinc.github.io/post/%E8%AE%B0%E4%B8%80%E6%AC%A1kafka-go%E4%BD%BF%E7%94%A8%E8%B8%A9%E5%9D%91%E5%A4%9A%E4%B8%AApartition%E5%8F%AA%E4%BC%9A%E5%86%99%E5%85%A5%E4%B8%80%E4%B8%AApartition/</link>
      <pubDate>Wed, 06 Nov 2019 05:33:44 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/%E8%AE%B0%E4%B8%80%E6%AC%A1kafka-go%E4%BD%BF%E7%94%A8%E8%B8%A9%E5%9D%91%E5%A4%9A%E4%B8%AApartition%E5%8F%AA%E4%BC%9A%E5%86%99%E5%85%A5%E4%B8%80%E4%B8%AApartition/</guid>
      <description>kafka-go地址: https://github.com/segmentio/kafka-go
 注意：本文解决的问题不是因为kafka配置造成的，是因为代码写得有问题。
今天查看公司某kafka group消费情况的时候，发现该group消费的topic大多数的message写入了同一个partition，先从配置问题查找，后来又去看公司包装的kafka的库的源码查找，看起来都没啥问题。
并且，该问题就出现在一个服务里面，很是让人迷惑。该服务和其他服务最大的不同在于，它每一次都只会发送一个message给kafka。
先看看，kafka-go的demo：
1 2 3 4 5 6 7 8 9 10 11  w := kafka.NewWriter(kafka.WriterConfig{ Brokers: []string{&amp;#34;localhost:9092&amp;#34;}, Topic: &amp;#34;topic-A&amp;#34;, Balancer: &amp;amp;kafka.LeastBytes{}, })   第一个看起来没啥问题，我发现公司代码也是照抄的，继续往NewWriter这个函数里面看，会发现这东西居然是起了一个协程，然后再去查看LeastBytes这个Balancer，他的Balance方法是依赖结构体中字段的状态的，每一次发送的时候都去创建一个新的Balancer，你不翻车谁翻车啊。
因为代码是每次都发送一个message，每次都是一个新的Balancer，所以Balancer每次只需Balance的状态都是一致，所以会造成只写入一个partition中。
总结一下，这个问题可大可小，数据量不大，程序抗得住当然没什么，但是总有一天会扛不住。所以奉劝一句，写完代码记得认认真真测试，程序跑得起来不代表正确。</description>
    </item>
    
    <item>
      <title>定时统计任务参考</title>
      <link>https://siskinc.github.io/post/%E5%AE%9A%E6%97%B6%E7%BB%9F%E8%AE%A1%E4%BB%BB%E5%8A%A1%E5%8F%82%E8%80%83/</link>
      <pubDate>Fri, 01 Nov 2019 22:12:47 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/%E5%AE%9A%E6%97%B6%E7%BB%9F%E8%AE%A1%E4%BB%BB%E5%8A%A1%E5%8F%82%E8%80%83/</guid>
      <description>  时间的触发，过期的数据不再使用（数据来源是消息中间件）
  相关联的任务使用事件的方式，例如一天的统计数据是需要小时的数据来生成的，当一天的小时数据生成完了，再去触发生成一天的数据，请勿使用延时的观念，是神坑，勿入。
  数据的读取，采用批量的方式读取，一次读取一个限定的值的数量。
  数据的写入，采用批量的方式写入，最好有ticker来触发写入未到阈值数量的数据。
  撸数据是一次sql撸完，还是分页撸？DBA告诉我让我一次撸完。
  </description>
    </item>
    
    <item>
      <title>CSS清除浮动</title>
      <link>https://siskinc.github.io/post/css%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/</link>
      <pubDate>Fri, 25 Oct 2019 14:29:00 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/css%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/</guid>
      <description>使用方法：1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  .clearfix:after { content: &amp;#34;&amp;#34;; display: block; height: 0; clear: both; visibility: hidden; } /* IE6、7专有 */ .clearfix { *zoom: 1; }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  .clearfix:before, .</description>
    </item>
    
    <item>
      <title>golang自动调用结构体中内嵌字段的Init()函数</title>
      <link>https://siskinc.github.io/post/golang%E8%87%AA%E5%8A%A8%E8%B0%83%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E5%86%85%E5%B5%8C%E5%AD%97%E6%AE%B5%E7%9A%84init%E5%87%BD%E6%95%B0/</link>
      <pubDate>Thu, 26 Sep 2019 13:31:39 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/golang%E8%87%AA%E5%8A%A8%E8%B0%83%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E5%86%85%E5%B5%8C%E5%AD%97%E6%AE%B5%E7%9A%84init%E5%87%BD%E6%95%B0/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81  package main import ( &amp;#34;fmt&amp;#34; &amp;#34;reflect&amp;#34; ) type initial interface { Init() } func triggerInitials(c interface{}) { rv := reflect.</description>
    </item>
    
    <item>
      <title>Linux进程的五个段</title>
      <link>https://siskinc.github.io/post/linux%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BA%94%E4%B8%AA%E6%AE%B5/</link>
      <pubDate>Sat, 24 Aug 2019 08:06:58 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/linux%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BA%94%E4%B8%AA%E6%AE%B5/</guid>
      <description>数据段  用来存放可执行文件中已初始化的全局变量，换句话说就是存放程序静态分配的变量和全局变量；
 代码段  代码段是用来存放可执行文件的操作指令，也就是说它是可执行程序在内存中的镜像。代码段需要防止在运行时被非法修改，所以只允许读取操作，而不允许写入（修改）操作&amp;mdash;&amp;ndash;它是不可写的；
 BSS段  包含了程序中未初始化的全局变量，在内存中bss段全部置零；
 堆（heap）  堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可以动态扩展或者所建。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩展）；当利用free等函数释放内存时，被释放的内存从堆中被提出（堆被缩减）；
 栈  栈是用户存放程序临时创建的局部变量，也就是说我们函数括弧中定义的变量（但是并不包括static声明的变量，static意味着在数据段中存放变量）.除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出的特点，所以栈特别方便用来保存/回复调用现场。从这个意义上讲，我们可以把栈看成一个寄存，交换临时数据的内存区。它是由操作系统分配的，内存的申请与回收都由OS管理。
 </description>
    </item>
    
    <item>
      <title>进程和线程有什么区别</title>
      <link>https://siskinc.github.io/post/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sat, 24 Aug 2019 07:33:48 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</guid>
      <description>定义 进程  是具有一定独立功能的程序、它是系统进行资源分配和调度的一个独立单位，重点在系统调度和单独的单位，也就是说进程是可以独 立运行的一段程序。
 线程  线程进程的一个实体，是CPU调度和分派的基本单位，他是比进程更小的能独立运行的基本单位，线程自己基本上不拥有系统资源。在运行时，只是暂用一些计数器、寄存器和栈 。
 关系   一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程（通常说的主线程）。
  资源分配给进程，同一进程的所有线程共享该进程的所有资源。用户进程主要段segment：stack（向低地址），heap，.rodata,data/bss,.text。一个进程，上面的5部分是主要的，必须的。线程只拥有stack（线程栈，线程栈是单个线程所独享的，2M），保存自己的函数调用过程，比如heap，.rodata,data/bss，text段都是共享的。
  线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。
  处理机分给线程，即真正在处理机上运行的是线程。
  线程是指进程内的一个执行单元，也是进程内的可调度实体。
  区别   调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位。
  并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可以并发执行。
  拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。
  </description>
    </item>
    
    <item>
      <title>Goroutines和线程对比</title>
      <link>https://siskinc.github.io/post/goroutines%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%AF%B9%E6%AF%94/</link>
      <pubDate>Thu, 15 Aug 2019 22:31:52 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/goroutines%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%AF%B9%E6%AF%94/</guid>
      <description>栈不同   线程：每一个OS线程都有一个固定大小的内存块(一般会是2MB)来做栈，这个栈会用来存储当前正在被调用或挂起(指在调用其它函数时)的函数的内部变量。固定大小的栈对于更复杂或者更深层次的递归函数调用来说显然是不够的。修改固定的大小可以提升空间的利用率允许创建更多的线程，并且可以允许更深的递归调用，不过这两者是没法同时兼备的。
  goroutine：一个goroutine会以一个很小的栈开始其生命周期，一般只需要2KB。一个goroutine的栈，和操作系统线程一样，会保存其活跃或挂起的函数调用的本地变量，但是和OS线程不太一样的是一个goroutine的栈大小并不是固定的；栈的大小会根据需要动态地伸缩。而goroutine的栈的最大值有1GB，比传统的固定大小的线程栈要大得多，尽管一般情况下，大多goroutine都不需要这么大的栈。
  调度不同   线程：OS线程会被操作系统内核调度。每几毫秒，一个硬件计时器会中断处理器，这会调用一个叫作scheduler的内核函数。这个函数会挂起当前执行的线程并保存内存中它的寄存器内容，检查线程列表并决定下一次哪个线程可以被运行，并从内存中恢复该线程的寄存器信息，然后恢复执行该线程的现场并开始执行线程。因为操作系统线程是被内核所调度，所以从一个线程向另一个“移动”需要完整的上下文切换，也就是说，保存一个用户线程的状态到内存，恢复另一个线程的到寄存器，然后更新调度器的数据结构。这几步操作很慢，因为其局部性很差需要几次内存访问，并且会增加运行的cpu周期。
  goroutine：Go的运行时包含了其自己的调度器，这个调度器使用了一些技术手段，比如m:n调度，因为其会在n个操作系统线程上多工(调度)m个goroutine。Go调度器的工作和内核的调度是相似的，但是这个调度器只关注单独的Go程序中的goroutine。和操作系统的线程调度不同的是，Go调度器并不是用一个硬件定时器而是被Go语言&amp;quot;建筑&amp;quot;本身进行调度的。例如当一个goroutine调用了time.Sleep或者被channel调用或者mutex操作阻塞时，调度器会使其进入休眠并开始执行另一个goroutine直到时机到了再去唤醒第一个goroutine。因为这种调度方式不需要进入内核的上下文，所以重新调度一个goroutine比调度一个线程代价要低得多。
  GOMAXPROCS Go的调度器使用了一个叫做GOMAXPROCS的变量来决定会有多少个操作系统的线程同时执行Go的代码。其默认的值是运行机器上的CPU的核心数，所以在一个有8个核心的机器上时，调度器一次会在8个OS线程上去调度GO代码。(GOMAXPROCS是前面说的m:n调度中的n)。在休眠中的或者在通信中被阻塞的goroutine是不需要一个对应的线程来做调度的。在I/O中或系统调用中或调用非Go语言函数时，是需要一个对应的操作系统线程的，但是GOMAXPROCS并不需要将这几种情况计算在内。
你可以用GOMAXPROCS的环境变量来显式地控制这个参数，或者也可以在运行时用runtime.GOMAXPROCS函数来修改它。我们在下面的小程序中会看到GOMAXPROCS的效果，这个程序会无限打印0和1。
1 2 3 4 5 6 7 8 9  for { go fmt.Print(0) fmt.Print(1) }   1 2 3 4 5 6 7 8 9 10 11  $ GOMAXPROCS=1 go run hacker-cliché.go 111111111111111111110000000000000000000011111... $ GOMAXPROCS=2 go run hacker-cliché.go 010101010101010101011001100101011010010100110...   在第一次执行时，最多同时只能有一个goroutine被执行。初始情况下只有main goroutine被执行，所以会打印很多1。过了一段时间后，GO调度器会将其置为休眠，并唤醒另一个goroutine，这时候就开始打印很多0了，在打印的时候，goroutine是被调度到操作系统线程上的。在第二次执行时，我们使用了两个操作系统线程，所以两个goroutine可以一起被执行，以同样的频率交替打印0和1。我们必须强调的是goroutine的调度是受很多因子影响的，而runtime也是在不断地发展演进的，所以这里的你实际得到的结果可能会因为版本的不同而与我们运行的结果有所不同。
Goroutine没有ID号 在大多数支持多线程的操作系统和程序语言中，当前的线程都有一个独特的身份(id)，并且这个身份信息可以以一个普通值的形式被被很容易地获取到，典型的可以是一个integer或者指针值。这种情况下我们做一个抽象化的thread-local storage(线程本地存储，多线程编程中不希望其它线程访问的内容)就很容易，只需要以线程的id作为key的一个map就可以解决问题，每一个线程以其id就能从中获取到值，且和其它线程互不冲突。</description>
    </item>
    
    <item>
      <title>数组中重复的数字(Python)</title>
      <link>https://siskinc.github.io/post/%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97python/</link>
      <pubDate>Tue, 13 Aug 2019 22:48:18 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97python/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107  #!</description>
    </item>
    
    <item>
      <title>数组中重复的数字(Golang)</title>
      <link>https://siskinc.github.io/post/%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97golang/</link>
      <pubDate>Tue, 13 Aug 2019 22:26:43 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97golang/</guid>
      <description>使用哈希表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  import &amp;#34;fmt&amp;#34; func main() { a := [...]int{2,3,1,0,2,5,3} num := make(map[int]bool) for _, v := range a { if !num[v] { num[v] = true } else { fmt.Println(v) } } }   排序查找 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  package main import ( &amp;#34;fmt&amp;#34; &amp;#34;sort&amp;#34; ) func main() { a := []int{2,3,1,0,2,5,3} sort.</description>
    </item>
    
    <item>
      <title>Golang 实现单例模式</title>
      <link>https://siskinc.github.io/post/golang_%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 13 Aug 2019 21:47:01 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/golang_%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  package main import &amp;#34;fmt&amp;#34; type Single struct { } var single *Single func GetSingle() *Single { if single == nil { single = &amp;amp;Single{} } return single } func main() { fmt.</description>
    </item>
    
    <item>
      <title>Python实现单例模式</title>
      <link>https://siskinc.github.io/post/python%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 13 Aug 2019 21:20:41 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/python%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>使用__new__方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Singleton(object): def __new__(cls, *args, **kw): if not hasattr(cls, &amp;#39;_instance&amp;#39;): orig = super(Singleton, cls) cls._instance = orig.__new__(cls, *args, **kw) return cls._instance class MyClass(Singleton): pass   共享属性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Borg(object): _state = {} def __new__(cls, *args, **kw): ob = super(Borg, cls).</description>
    </item>
    
    <item>
      <title>svn branch 创建分支</title>
      <link>https://siskinc.github.io/post/svn_branch_%E5%88%9B%E5%BB%BA%E5%88%86%E6%94%AF/</link>
      <pubDate>Fri, 26 Jul 2019 09:49:33 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/svn_branch_%E5%88%9B%E5%BB%BA%E5%88%86%E6%94%AF/</guid>
      <description>  </description>
    </item>
    
    <item>
      <title>使用docker-compose搭建WordPress</title>
      <link>https://siskinc.github.io/post/%E4%BD%BF%E7%94%A8docker-compose%E6%90%AD%E5%BB%BAwordpress/</link>
      <pubDate>Thu, 25 Jul 2019 23:18:13 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/%E4%BD%BF%E7%94%A8docker-compose%E6%90%AD%E5%BB%BAwordpress/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101  version:&amp;#39;3&amp;#39;services:nginx:image:nginx:1.</description>
    </item>
    
    <item>
      <title>shell中通过eval执行一个字符串命令</title>
      <link>https://siskinc.github.io/post/shell%E4%B8%AD%E9%80%9A%E8%BF%87eval%E6%89%A7%E8%A1%8C%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Thu, 25 Jul 2019 20:39:15 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/shell%E4%B8%AD%E9%80%9A%E8%BF%87eval%E6%89%A7%E8%A1%8C%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%91%BD%E4%BB%A4/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13  #!/bin/bash echo &amp;#34;Switch Directory : /home/pktgen-2.9.0&amp;#34; dir=&amp;#34;/home/pktgen-2.9.0&amp;#34; cd $dir cmd=&amp;#34;./pktgen_20180410 -c f -n 4 --proc-type auto --socket-mem 512 -b 01:00.1 --file-prefix pg1 -- -T -m 3.0 -s 0:voip-udp.pcap:2 -d 10000 --bps 1500&amp;#34; eval $cmd   </description>
    </item>
    
    <item>
      <title>svn钩子(hooks)</title>
      <link>https://siskinc.github.io/post/svn%E9%92%A9%E5%AD%90hooks/</link>
      <pubDate>Thu, 25 Jul 2019 20:37:23 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/svn%E9%92%A9%E5%AD%90hooks/</guid>
      <description>钩子脚本的具体写法就是操作系统中shell脚本程序的写法,请根据自己SVN所在的操作系统和shell程序进行相应的写作
所谓钩子就是与一些版本库事件触发的程序，例如新修订版本的创建，或是未版本化属性的修改。每个钩子都会被告知足够多的信息，包括那是什么事件，所操作的对象，和触发事件的用户名。通过钩子的输出或返回状态，钩子程序能让工作继续、停止或是以某种方式挂起。
svn在每个代码仓库下有一个hooks目录用于放hook脚本, svn为我们提供了模板
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  [root@idcflow2175 hooks]# pwd /home/svn/csvn/data/repositories/tr2/hooks [root@idcflow2175 hooks]# ll -rw-r--r-- 1 svn svn 1977 Jul 1 2013 post-commit.tmpl -rw-r--r-- 1 svn svn 1638 Jul 1 2013 post-lock.tmpl -rw-r--r-- 1 svn svn 2289 Jul 1 2013 post-revprop-change.tmpl -rw-r--r-- 1 svn svn 1567 Jul 1 2013 post-unlock.</description>
    </item>
    
    <item>
      <title>使用Docker搭建svn服务器教程</title>
      <link>https://siskinc.github.io/post/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAsvn%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%99%E7%A8%8B/</link>
      <pubDate>Thu, 25 Jul 2019 20:36:47 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAsvn%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%99%E7%A8%8B/</guid>
      <description>svn简介 SVN是Subversion的简称，是一个开放源代码的版本控制系统，相较于RCS、CVS，它采用了分支管理系统，它的设计目标就是取代CVS。互联网上很多版本控制服务已从CVS迁移到Subversion。说得简单一点SVN就是用于多个人共同开发同一个项目，共用资源的目的。
svn的docker搭建方法   请提前在服务器安装好docker服务
  本篇教程选用的docker镜像为garethflowers/svn-server
  安装并启动容器代码
  1 2 3  docker run --restart always --name svn -d -v /root/dockers/svn:/var/opt/svn -p 3690:3690 garethflowers/svn-server   简析   /root/dockers/svn为宿主机的文件目录，/var/opt/svn为容器内的文件目录
  &amp;ndash;restart always命令可以实现容器在宿主机开机时自启动
  -p 3690:3690表示将宿主机的3690端口映射到容器的3690端口，此端口为svn服务的默认端口，可以根据需要自行修改
  创建svn仓库和账户 进入容器中进行配置 1 2 3  docker exec -it svn /bin/sh   创建名称为svn的资源仓库 1 2 3  svnadmin create svn   创建成功后svn目录内应该包含以下文件:</description>
    </item>
    
    <item>
      <title>docker xfs卡死</title>
      <link>https://siskinc.github.io/post/docker_xfs%E5%8D%A1%E6%AD%BB/</link>
      <pubDate>Thu, 25 Jul 2019 20:36:20 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/docker_xfs%E5%8D%A1%E6%AD%BB/</guid>
      <description>原因 docker在xfs文件系统中，过于频繁create/destory container、pull/push image，当thin pool满时，DeviceMapper后端默认文件系统xfs会不断retry 失败的IO，导致进程挂起。
解决办法   不用xfs文件系统
  加入启动参数 dm.xfs_nospace_max_retries=0
  </description>
    </item>
    
    <item>
      <title>如何在mongoengine中使用referencefield引用本类</title>
      <link>https://siskinc.github.io/post/%E5%A6%82%E4%BD%95%E5%9C%A8mongoengine%E4%B8%AD%E4%BD%BF%E7%94%A8referencefield%E5%BC%95%E7%94%A8%E6%9C%AC%E7%B1%BB/</link>
      <pubDate>Thu, 25 Jul 2019 20:35:44 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/%E5%A6%82%E4%BD%95%E5%9C%A8mongoengine%E4%B8%AD%E4%BD%BF%E7%94%A8referencefield%E5%BC%95%E7%94%A8%E6%9C%AC%E7%B1%BB/</guid>
      <description>引用：原文
1 2 3 4 5 6 7 8 9 10 11  from mongoengine import * class Employee(Document): name = StringField() boss = ReferenceField(&amp;#34;self&amp;#34;, reverse_delete_rule = NULLIFY)   </description>
    </item>
    
    <item>
      <title>docker一键ss</title>
      <link>https://siskinc.github.io/post/docker%E4%B8%80%E9%94%AEss/</link>
      <pubDate>Thu, 25 Jul 2019 20:35:01 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/docker%E4%B8%80%E9%94%AEss/</guid>
      <description>1 2 3  sudo docker run -dt --name ssserver -p 6443:6443 -p 8188:8188/udp mritd/shadowsocks -m &amp;#34;ss-server&amp;#34; -s &amp;#34;-s 0.0.0.0 -p 6443 -m chacha20-ietf-poly1305 -k yourpassword&amp;#34; -x -e &amp;#34;kcpserver&amp;#34; -k &amp;#34;-t 127.0.0.1:6443 -l :8188 -mode fast2&amp;#34;   </description>
    </item>
    
    <item>
      <title>Linux or Mac 重启网络</title>
      <link>https://siskinc.github.io/post/linux_or_mac_%E9%87%8D%E5%90%AF%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Thu, 25 Jul 2019 20:34:24 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/linux_or_mac_%E9%87%8D%E5%90%AF%E7%BD%91%E7%BB%9C/</guid>
      <description>Mac 1 2 3 4 5  sudo ifconfig en0 down sudo ifconfig en0 up   Linux /etc/init.d/networking restart</description>
    </item>
    
    <item>
      <title>uwsgi flask gevent 测试代码覆盖率（coverage）</title>
      <link>https://siskinc.github.io/post/uwsgi_flask_gevent_%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87coverage/</link>
      <pubDate>Thu, 25 Jul 2019 20:33:29 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/uwsgi_flask_gevent_%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87coverage/</guid>
      <description>可能出现的问题   多进程启动
  gevent启动
  运行的服务可能不会停止
  解决 我先参考了一下这一篇文章使用Coverage分析WSGI项目的代码覆盖率，他基本能够解决掉1.2两个问题，第三个问题我是使用了一个接口来停止当前进程的coverage，接口返回一个当前进程的work_id，可以判断是否所以进程都结束了，然后进行coverage combine就行了</description>
    </item>
    
    <item>
      <title>次优二叉树</title>
      <link>https://siskinc.github.io/post/%E6%AC%A1%E4%BC%98%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Thu, 25 Jul 2019 20:31:14 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/%E6%AC%A1%E4%BC%98%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>原理  首先取出查找表中每个关键字及其对应的权值，采用如下公式计算出每个关键字对应的一个值：
  其中 wj 表示每个关键字的权值（被查找到的概率），h 表示关键字的个数。
 表中有多少关键字，就会有多少个 △Pi ，取其中最小的做为次优查找树的根结点，然后将表中关键字从第 i 个关键字的位置分成两部分，分别作为该根结点的左子树和右子树。同理，左子树和右子树也这么处理，直到最后构成次优查找树完成。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71  typedef int KeyType;//定义关键字类型  typedef struct{ KeyType key; }ElemType;//定义元素类型  typedef struct BiTNode{ ElemType data; struct BiTNode *lchild, *rchild; }BiTNode, *BiTree; //定义变量  int i; int min; int dw; //创建次优查找树，R数组为查找表，sw数组为存储的各关键字的概率（权值），low和high表示的sw数组中的权值的范围  void SecondOptimal(BiTree T, ElemType R[], float sw[], int low, int high){ //由有序表R[low.</description>
    </item>
    
    <item>
      <title>二叉搜索树</title>
      <link>https://siskinc.github.io/post/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link>
      <pubDate>Thu, 25 Jul 2019 20:29:05 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid>
      <description> 二叉查找树（英语：Binary Search Tree），也称为二叉搜索树、有序二叉树（ordered binary tree）或排序二叉树（sorted binary tree）
 性质 指一棵空树或者具有下列性质的二叉树：
  若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值
  若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；
  任意节点的左、右子树也分别为二叉查找树；
  没有键值相等的节点。
  优势 二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为O(logn)
。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如集合、多重集、关联数组等。
二叉搜索树的查找算法 在二叉搜索树b中查找x的过程为：
  若b是空树，则搜索失败，否则：
  若x等于b的根节点的数据域之值，则查找成功；否则：
  若x小于b的根节点的数据域之值，则搜索左子树；否则：
  查找右子树。
  在二叉搜索树插入节点的算法 向一个二叉搜索树b中插入一个节点s的算法，过程为：
  若b是空树，则将s所指节点作为根节点插入，否则：
  若s-&amp;gt;data等于b的根节点的数据域之值，则返回，否则：
  若s-&amp;gt;data小于b的根节点的数据域之值，则把s所指节点插入到左子树中，否则：
  把s所指节点插入到右子树中。（新插入节点总是叶子节点）
  </description>
    </item>
    
    <item>
      <title>vue-lazyload插件</title>
      <link>https://siskinc.github.io/post/vue-lazyload%E6%8F%92%E4%BB%B6/</link>
      <pubDate>Thu, 25 Jul 2019 20:28:20 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/vue-lazyload%E6%8F%92%E4%BB%B6/</guid>
      <description>使用 1 2 3  npm install vue-lazyload --save   1 2 3 4 5 6 7  //注册插件  import vueLazyload from &amp;#39;vue-lazyload&amp;#39; Vue.use(vueLazyload);   1 2 3 4 5  //在需要懒加载的图片上 &amp;lt;img v-lazy=&amp;#34;imgUrl&amp;#34;&amp;gt;   参数说明 注册插件的时候，是可以传入第二个配置参数的
1 2 3  Vue.use(vueLazyload,{})   可选的参数如下：
preLoad:类型Number,默认1.3. 表示lazyload的元素距离页面底部距离的百分比.计算值为(preload - 1).
attempt:图片加载失败后的重试次数.默认为3.
error:类型string.图片加载失败后的显示的失败图片路径.
loading:类型string.图片正在加载中显示的loading图片的路径.
listenEvents:类型array.默认[&amp;lsquo;scroll&amp;rsquo;, &amp;lsquo;wheel&amp;rsquo;, &amp;lsquo;mousewheel&amp;rsquo;, &amp;lsquo;resize&amp;rsquo;, &amp;lsquo;animationend&amp;rsquo;, &amp;lsquo;transitionend&amp;rsquo;, &amp;lsquo;touchmove&amp;rsquo;].即是在监听上述事件中,判断图片是否在preload的位置.如果你不想在那么多事件中判断,可以指定一个或者几个.例如如果你给这个属性只指定[&amp;lsquo;touchmove&amp;rsquo;].那么scroll 屏幕不会加载图片,只有手指滑动屏幕才会加载图片.
adapter:注册img 的loading,loaded,error三个状态的回调函数,参数会暴露懒加载的img元素,可以对其进行操作.
filter: img未加载之前,解析到src 的时候注册的回调函数.可以在加载图片之前,对src进行修改.注册在filter下的所有的函数都会执行
lazyComponent:类型Boolean.是否启用懒加载组件.组件中的内容只有在出现在preload的位置中才会加载组件.这个lazyloadComponent 组件有个缺点就是,组件在加载前是什么都不渲染的,这样子的话,有可能会影响布局,以及加载前到加载后的切换不好,有点突兀和生硬.</description>
    </item>
    
    <item>
      <title>python中检测某个变量是否有定义</title>
      <link>https://siskinc.github.io/post/python%E4%B8%AD%E6%A3%80%E6%B5%8B%E6%9F%90%E4%B8%AA%E5%8F%98%E9%87%8F%E6%98%AF%E5%90%A6%E6%9C%89%E5%AE%9A%E4%B9%89/</link>
      <pubDate>Thu, 25 Jul 2019 20:27:52 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/python%E4%B8%AD%E6%A3%80%E6%B5%8B%E6%9F%90%E4%B8%AA%E5%8F%98%E9%87%8F%E6%98%AF%E5%90%A6%E6%9C%89%E5%AE%9A%E4%B9%89/</guid>
      <description>第一种方法使用内置函数locals() &#39;testvar&#39; in locals().keys()
第二种方法使用内置函数dir() &#39;testvar&#39; in dir()
第三种方法使用内置函数vars() vars().has_key(&#39;testvar&#39;)</description>
    </item>
    
    <item>
      <title>Python 同级目录import报错</title>
      <link>https://siskinc.github.io/post/python_%E5%90%8C%E7%BA%A7%E7%9B%AE%E5%BD%95import%E6%8A%A5%E9%94%99/</link>
      <pubDate>Thu, 25 Jul 2019 20:27:18 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/python_%E5%90%8C%E7%BA%A7%E7%9B%AE%E5%BD%95import%E6%8A%A5%E9%94%99/</guid>
      <description> 在使用protobuf时，我们自己了各种Options的时候，在生成的python文件会在同级目录中引用，所以这个时候我们不能做到，加个__init__.py文件了事然后在文件里面写 import mudole.file这样的代码，因为我们自己无法控制
 解决方法如下，在__init__文件中加入以下代码:
1 2 3 4 5 6 7  import sys import os sys.path.append(os.path.dirname(&amp;#39;mudole_name/&amp;#39;))   </description>
    </item>
    
    <item>
      <title>flask返回自定义的Response</title>
      <link>https://siskinc.github.io/post/flask%E8%BF%94%E5%9B%9E%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84response/</link>
      <pubDate>Thu, 25 Jul 2019 20:26:43 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/flask%E8%BF%94%E5%9B%9E%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84response/</guid>
      <description>from json import dumpsfrom flask import Responsefrom flask_api import statusfrom protocol.errors_pb2 import *class ErrorResponse(Response):def __init__(self, err_code, err_msg=&#39;&#39;):result = dumps(dict(code=err_code, msg=err_msg))Response.__init__(self, result, mimetype=&#39;application/json&#39;)class JSONResponse(Response):def __init__(self, data, msg=&#39;&#39;):result = dumps(dict(data=data, code=Error_None, msg=msg))Response.__init__(self, result, mimetype=&#39;application/json&#39;)class UnauthorizedResponse(Response):def __init__(self):data = dumps(dict(msg=&amp;quot;need login&amp;quot;, code=Error_NeedLogin, data=None))Response.__init__(self, data, mimetype=&#39;application/json&#39;, status=status.HTTP_401_UNAUTHORIZED)注意：一定要使用json.dumps来转换最后的结果</description>
    </item>
    
    <item>
      <title>Gin上传文件到MongoDB gridfs</title>
      <link>https://siskinc.github.io/post/gin%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0mongodb_gridfs/</link>
      <pubDate>Thu, 25 Jul 2019 20:25:30 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/gin%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0mongodb_gridfs/</guid>
      <description>上传图片 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103  func imagePost(c *gin.</description>
    </item>
    
    <item>
      <title>Django上传图片</title>
      <link>https://siskinc.github.io/post/django%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/</link>
      <pubDate>Thu, 25 Jul 2019 20:24:51 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/django%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/</guid>
      <description>model 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  from django.db import models class Picture(models.Model): path = models.ImageField(upload_to=&amp;#39;share_pictures/&amp;#39;) name = models.CharField(max_length = 50) class Meta: db_table = &amp;#34;picture&amp;#34; def __str__(self): return self.name   forms 1 2 3 4 5 6 7 8 9 10 11  from django import forms class ImageForm(forms.</description>
    </item>
    
    <item>
      <title>当我们接到一个需求时，我们应该做一些什么呢？</title>
      <link>https://siskinc.github.io/post/%E5%BD%93%E6%88%91%E4%BB%AC%E6%8E%A5%E5%88%B0%E4%B8%80%E4%B8%AA%E9%9C%80%E6%B1%82%E6%97%B6%E6%88%91%E4%BB%AC%E5%BA%94%E8%AF%A5%E5%81%9A%E4%B8%80%E4%BA%9B%E4%BB%80%E4%B9%88%E5%91%A2/</link>
      <pubDate>Thu, 25 Jul 2019 20:24:04 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/%E5%BD%93%E6%88%91%E4%BB%AC%E6%8E%A5%E5%88%B0%E4%B8%80%E4%B8%AA%E9%9C%80%E6%B1%82%E6%97%B6%E6%88%91%E4%BB%AC%E5%BA%94%E8%AF%A5%E5%81%9A%E4%B8%80%E4%BA%9B%E4%BB%80%E4%B9%88%E5%91%A2/</guid>
      <description>沟通需求  不论是什么样的团队，按照道理来说一定会有一个和你对接的产品
   沟通大致的轮廓，一般来说，产品不会把东西都会给你说清楚，因为很多人都是很被动的，喜欢一问一答的方式。
  知道了一个需求的大致内容，现在应该去每一句话的去分享需求文档，然后发掘里面的细节，查看会不会影响到程序的实现，或者会影响到其他的功能，这些都是我们开发人员需要去注意的。
  现在已经确认程序能够去实现这个需求，那么我们应该做什么呢？先分析我们需要如何去实现，并且应该多想想能不能有其他的实现方案，哪一个更好？
  要保证一个功能完美的在线上运行，我们最需要的是测试，我们在开发前就应该我们应该测试的案例，一开始你可能写不出来，无所谓，等你慢慢成为老油条，你一眼就知道要做些啥，而且这个东西不要只停留在想想中，一定要记下来，在开发过程中你还会想到许许多多的测试案例，也都记下来，不要偷懒，偷懒的后果出现bug会导致你被好几个人怼，包括测试。
  开发，有前面的测试案例的发散，在写代码的过程你会发现，你会注意很多问题，包括边界条件。
  自主测试，其实一个功能，最了解他的除了产品，可能就是你自己了，你知道怎么实现的，你最应该知道怎么测试，而且，测试人员也会有打盹的时候，很多时候我自己测试过后给了测试，依然会有bug，也就是说，测试人员的测试案例依然还是在我写的测试案例中，在不断积累的下，你会发现你的一个小需求可能会测试很多个测试案例，这是一个好事，这样你的功能才会在线上健壮的跑下去。
  </description>
    </item>
    
    <item>
      <title>Python any() 函数</title>
      <link>https://siskinc.github.io/post/python_any_%E5%87%BD%E6%95%B0/</link>
      <pubDate>Thu, 25 Jul 2019 17:50:44 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/python_any_%E5%87%BD%E6%95%B0/</guid>
      <description>any() 函数用于判断给定的可迭代参数 iterable 是否全部为 False，则返回 False，如果有一个为 True，则返回 True。
元素除了是 0、空、FALSE 外都算 TRUE。
如果想要测试一个list中是否有一个是1可以使用any，例如：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  x, y, z = 0, 1, 0 if x == 1 or y == 1 or z == 1: print(&amp;#39;passed&amp;#39;) if 1 in (x, y, z): print(&amp;#39;passed&amp;#39;) # These only test for truthiness: if x or y or z: print(&amp;#39;passed&amp;#39;) if any((x, y, z)): print(&amp;#39;passed&amp;#39;)   </description>
    </item>
    
    <item>
      <title>Python如何合并两个字典</title>
      <link>https://siskinc.github.io/post/python%E5%A6%82%E4%BD%95%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E5%AD%97%E5%85%B8/</link>
      <pubDate>Thu, 25 Jul 2019 17:50:14 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/python%E5%A6%82%E4%BD%95%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E5%AD%97%E5%85%B8/</guid>
      <description>Python 3
1 2 3 4 5 6 7  x = {&amp;#39;a&amp;#39;: 1, &amp;#39;b&amp;#39;: 2} y = {&amp;#39;b&amp;#39;: 3, &amp;#39;c&amp;#39;: 4} z = {**x, **y}   Python 2
1 2 3  z = dict(x, **y)    Python中只能处理这种简单的合并，如果出现相同的key，Python会选择覆盖
 </description>
    </item>
    
    <item>
      <title>Python中下划线的5种含义</title>
      <link>https://siskinc.github.io/post/python%E4%B8%AD%E4%B8%8B%E5%88%92%E7%BA%BF%E7%9A%845%E7%A7%8D%E5%90%AB%E4%B9%89/</link>
      <pubDate>Thu, 25 Jul 2019 17:46:49 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/python%E4%B8%AD%E4%B8%8B%E5%88%92%E7%BA%BF%E7%9A%845%E7%A7%8D%E5%90%AB%E4%B9%89/</guid>
      <description>单前导下划线 _var 当涉及到变量和方法名称时，单个下划线前缀有一个约定俗成的含义。 它是对程序员的一个提示 - 意味着Python社区一致认为它应该是什么意思，但程序的行为不受影响。
下划线前缀的含义是告知其他程序员：以单个下划线开头的变量或方法仅供内部使用。 该约定在PEP 8中有定义。
单末尾下划线 var_ 有时候，一个变量的最合适的名称已经被一个关键字所占用。 因此，像class或def这样的名称不能用作Python中的变量名称。 在这种情况下，你可以附加一个下划线来解决命名冲突。总之，单个末尾下划线（后缀）是一个约定，用来避免与Python关键字产生命名冲突。 PEP 8解释了这个约定。
双前导下划线 __var 到目前为止，我们所涉及的所有命名模式的含义，来自于已达成共识的约定。 而对于以双下划线开头的Python类的属性（包括变量和方法），情况就有点不同了。
双下划线前缀会导致Python解释器重写属性名称，以避免子类中的命名冲突。
这也叫做名称修饰（name mangling） - 解释器更改变量的名称（例如：class名为Test, 变量名为__a,那么__a会被Python解释器重写属性名为_Test__a），以便在类被扩展的时候不容易产生冲突。名称修饰会影响在一个类的上下文中，以两个下划线字符（&amp;ldquo;dunders&amp;rdquo;）开头的所有名称。
双前导和双末尾下划线 var 如果一个名字同时以双下划线开始和结束，则不会应用名称修饰。 由双下划线前缀和后缀包围的变量不会被Python解释器修改。
单下划线 _ 按照习惯，有时候单个独立下划线是用作一个名字，来表示某个变量是临时的或无关紧要的。你也可以在拆分(unpacking)表达式中将单个下划线用作“不关心的”变量，以忽略特定的值。 同样，这个含义只是“依照约定”，并不会在Python解释器中触发特殊的行为。 单个下划线仅仅是一个有效的变量名称，会有这个用途而已。
除了用作临时变量之外，“_”是大多数Python REPL中的一个特殊变量，它表示由解释器评估的最近一个表达式的结果。
Python下划线命名模式 - 小结 evernotecid://9326179B-5200-4478-B32E-B919B94B243C/appyinxiangcom/21231346/ENResource/p4</description>
    </item>
    
    <item>
      <title>Golang不会自动把slice转换成interface{}类型的slice</title>
      <link>https://siskinc.github.io/post/golang%E4%B8%8D%E4%BC%9A%E8%87%AA%E5%8A%A8%E6%8A%8Aslice%E8%BD%AC%E6%8D%A2%E6%88%90interface%E7%B1%BB%E5%9E%8B%E7%9A%84slice/</link>
      <pubDate>Thu, 25 Jul 2019 17:46:17 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/golang%E4%B8%8D%E4%BC%9A%E8%87%AA%E5%8A%A8%E6%8A%8Aslice%E8%BD%AC%E6%8D%A2%E6%88%90interface%E7%B1%BB%E5%9E%8B%E7%9A%84slice/</guid>
      <description>例子 我们时常会写一些interface，例如：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  type A interface{ Print() } type B struct { } func (b *B) Print() { fmt.Println(&amp;#34;Here is *B&amp;#34;) }   赋值的时候:
1 2 3 4 5  var a A a = &amp;amp;B{}   诶，这样看视乎没什么问题，但是我们没有办法避免使用数组，然后顺手就写了这样的代码
1 2 3 4 5  var aa []A aa = make([]*B, 10)   好的，现在翻车了，会得到一个这样的报错：</description>
    </item>
    
    <item>
      <title>Python源码阅读——PyAPI_FUNC,PyAPI_DATA,PyMODINIT_FUNC</title>
      <link>https://siskinc.github.io/post/python%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BBpyapi_funcpyapi_datapymodinit_func/</link>
      <pubDate>Thu, 25 Jul 2019 17:45:35 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/python%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BBpyapi_funcpyapi_datapymodinit_func/</guid>
      <description>PyAPI_FUNC(type):申明一个公共的Python API函数并且返回一个PyObject*代表对应的类型
 PyAPI_DATA(type): 声明公共的Python数据和类型
PyMODINIT_FUNC: 一个Python模块初始化函数。如果这些函数是在Python内核的，他们就提供Python的内核。如果是一个扩展的模块。那可能需要拓展库支持平台的外部连接
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121  /* All windows ports, except cygwin, are handled in PC/pyconfig.</description>
    </item>
    
    <item>
      <title>Python源码阅读——基础</title>
      <link>https://siskinc.github.io/post/python%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Thu, 25 Jul 2019 17:44:55 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/python%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%9F%BA%E7%A1%80/</guid>
      <description>阅读源码的版本: cmmit id: 9e4f2f3a6b8ee995c365e86d976937c141d867f8
 在阅读Python的源码时，我们第一个想到的就是先去阅读Python的数据结构的源码。
那么，我们先去挨着看看。
数据结构 long 1 2 3 4 5 6 7 8 9 10 11  struct _longobject { PyObject_VAR_HEAD digit ob_digit[1]; };   list 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  typedef struct { PyObject_VAR_HEAD /* Vector of pointers to list elements.</description>
    </item>
    
    <item>
      <title>RTTI</title>
      <link>https://siskinc.github.io/post/rtti/</link>
      <pubDate>Thu, 25 Jul 2019 17:44:31 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/rtti/</guid>
      <description>RTTI是”Runtime Type Information”的缩写，意思是运行时类型信息，它提供了运行时确定对象类型的方法。
 typeid函数  对于c++的内置数据类型，typeid可以方便的输出它们的数据类型。
 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  #include &amp;lt;iostream&amp;gt; #include &amp;lt;typeinfo&amp;gt; using namespace std; int main() { short s = 2; unsigned ui = 10; int i = 10; char ch = &amp;#39;a&amp;#39;; wchar_t wch = L&amp;#39;b&amp;#39;; float f = 1.</description>
    </item>
    
    <item>
      <title>Python3 和 Python2的区别</title>
      <link>https://siskinc.github.io/post/python3_%E5%92%8C_python2%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Thu, 25 Jul 2019 17:36:53 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/python3_%E5%92%8C_python2%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>print   Python2.7的print不是一个function
  Python3里的print是一个function。
  Unicode   Python 2 有 ASCII str() 类型，unicode() 是单独的，不是 byte 类型。
  Python 3，我们最终有了 Unicode (utf-8) 字符串，以及一个字节类：byte 和 bytearrays。
  由于 Python3.X 源码文件默认使用utf-8编码，这就使得以下代码是合法的：
1 2 3 4 5 6 7  &amp;gt;&amp;gt;&amp;gt; 中国 = &amp;#39;china&amp;#39; &amp;gt;&amp;gt;&amp;gt;print(中国) china   Python 2.x
1 2 3 4 5 6 7 8 9 10 11 12 13  &amp;gt;&amp;gt;&amp;gt; str = &amp;#34;我爱北京天安门&amp;#34; &amp;gt;&amp;gt;&amp;gt; str &amp;#39;\xe6\x88\x91\xe7\x88\xb1\xe5\x8c\x97\xe4\xba\xac\xe5\xa4\xa9\xe5\xae\x89\xe9\x97\xa8&amp;#39; &amp;gt;&amp;gt;&amp;gt; str = u&amp;#34;我爱北京天安门&amp;#34; &amp;gt;&amp;gt;&amp;gt; str u&amp;#39;\u6211\u7231\u5317\u4eac\u5929\u5b89\u95e8&amp;#39;   Python 3.</description>
    </item>
    
    <item>
      <title>关于Python的导入覆盖解决办法</title>
      <link>https://siskinc.github.io/post/%E5%85%B3%E4%BA%8Epython%E7%9A%84%E5%AF%BC%E5%85%A5%E8%A6%86%E7%9B%96%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</link>
      <pubDate>Thu, 25 Jul 2019 17:36:26 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/%E5%85%B3%E4%BA%8Epython%E7%9A%84%E5%AF%BC%E5%85%A5%E8%A6%86%E7%9B%96%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</guid>
      <description>这种问题一般来说还是不会引起的，可能会出现在datetime和time这样类型的模块中。
例如：
1 2 3 4 5  import datetime from datetime import datetime   如果写在一个文件到倒是一眼能够看出来，主要是在公司这种多人协同合作的时候，导入相关模块的时候会出现覆盖的情况需要注意。
我的建议是将系统的模块放在最后面导入，自己写的模块放在前面，不过最好跟公司的人统一一下，统一使用import datetime就行。</description>
    </item>
    
    <item>
      <title>Python使用datetime来判断近七天</title>
      <link>https://siskinc.github.io/post/python%E4%BD%BF%E7%94%A8datetime%E6%9D%A5%E5%88%A4%E6%96%AD%E8%BF%91%E4%B8%83%E5%A4%A9/</link>
      <pubDate>Thu, 25 Jul 2019 17:35:46 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/python%E4%BD%BF%E7%94%A8datetime%E6%9D%A5%E5%88%A4%E6%96%AD%E8%BF%91%E4%B8%83%E5%A4%A9/</guid>
      <description>strptime 使用strptime来格式化字符串
1 2 3 4 5  datetime.datetime.strptime(&amp;#34;2019-10-02&amp;#34;, &amp;#34;%Y-%m-%d&amp;#34;) # datetime.datetime(2019, 1, 2, 0, 10)   timedelta 使用timedelta来进行计算天数
1 2 3 4 5 6 7 8 9 10 11 12 13  a = datetime.datetime.strptime(&amp;#34;2019-10-02&amp;#34;, &amp;#34;%Y-%m-%d&amp;#34;) b = datetime.datetime.strptime(&amp;#34;2019-10-01&amp;#34;, &amp;#34;%Y-%m-%d&amp;#34;) a - b # datetime.timedelta(1) (a - b).days # 1   </description>
    </item>
    
    <item>
      <title>Golang mgo 模糊查询的使用</title>
      <link>https://siskinc.github.io/post/golang_mgo_%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Thu, 25 Jul 2019 17:35:04 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/golang_mgo_%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>在日常使用的Mongodb中，有一项功能叫做模糊查询（使用正则匹配），例如:
db.article.find({&amp;quot;title&amp;quot;: {$regex: /a/, $options: &amp;quot;im&amp;quot;}})这是我们常用Mongodb的命令行使用的方式，但是在mgo中做出类似的方式视乎是行不通的：
1 2 3  query := bson.M{&amp;#34;title&amp;#34;: bson.M{&amp;#34;$regex&amp;#34;: &amp;#34;/a/&amp;#34;, &amp;#34;$options&amp;#34;: &amp;#34;im&amp;#34;}}   大家用这个方式去查询，能查询到算我输！
下面总结一下，正真使用的方式：
 在Mongodb的命令行中，我们可以使用形如 \abcd\ 的方式来作为我们的pattern，但是在mgo是直接传入字符串来进行的，也就是传入的是&amp;quot;\a&amp;quot;，而不是\a\。   根据第一点，我们将代码修改一下。
 1 2 3  query := bson.M{&amp;#34;title&amp;#34;: bson.M{&amp;#34;$regex&amp;#34;: &amp;#34;a&amp;#34;, &amp;#34;$options&amp;#34;: &amp;#34;im&amp;#34;}}    但是我们会发现依然不能得到我们想要的结果，那么第二点就会产生了！
 在mgo中要用到模糊查询需要mgo中自带的一个结构: bson.RegEx  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // RegEx represents a regular expression.</description>
    </item>
    
    <item>
      <title>关于Basic Latin踩到的一些坑</title>
      <link>https://siskinc.github.io/post/%E5%85%B3%E4%BA%8Ebasic_latin%E8%B8%A9%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/</link>
      <pubDate>Thu, 25 Jul 2019 17:34:19 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/%E5%85%B3%E4%BA%8Ebasic_latin%E8%B8%A9%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/</guid>
      <description>在wiki中，很多语言的字符集都包含了Basic Latin，一开始我没有细看，以为Basic Latin里面都是正常的字符集，后来在线上环境出现了问题
 博主某天接到一个需求，需要过滤出某国语言的字符集（避免出现Unicode中的不可见字符），于是高高兴兴的在维基百科上找到该语言字符集抄了下来
嗯，于是，线上环境出了一点小问题，由于我们某些功能是依赖于Basic Latin里面的特殊字符来做分割的，博主过于年轻，没有细看，于是翻车，卒，享年22岁。
先看看Basic Latin里面到底是什么：https://jrgraphix.net/r/Unicode/0020-007F
仔细看里面其实有很多特殊字符的，所以大多数程序员一般都会在正则表达式里面写0-9a-zA-Z来表示Basic Latin里面的东西，为什么不直接写\x0020-\x007F是有用意，以后看见一些东西还是不要随意忽略，就像为什么写0-9a-zA-Z来表示\x0020-\x007F，你以为别人是傻逼，写这么一长串干啥，实际上你是傻逼。</description>
    </item>
    
    <item>
      <title>mysql查看数据库和表的占用空间大小</title>
      <link>https://siskinc.github.io/post/mysql%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%8D%A0%E7%94%A8%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F/</link>
      <pubDate>Thu, 25 Jul 2019 17:33:47 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/mysql%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%8D%A0%E7%94%A8%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F/</guid>
      <description>查看数据库的大小 use 数据库名
SELECT sum(DATA_LENGTH)+sum(INDEX_LENGTH)
FROM information_schema.TABLES where TABLE_SCHEMA=&amp;lsquo;数据库名&amp;rsquo;;
得到的结果是以字节为单位，除1024为K，除1048576为M。
查看表的最后mysql修改时间 select TABLE_NAME,UPDATE_TIME from INFORMATION_SCHEMA.tables where TABLE_SCHEMA=&amp;lsquo;数据库名&amp;rsquo;;
可以通过查看数据库中表的mysql修改时间，来确定mysql数据库是否已经长期不再使用。
查看数据库中各个表占用的空间大小 如果想知道MySQL数据库中每个表占用的空间、表记录的行数的话，可以打开MySQL的 information_schema 数据库。在该库中有一个 TABLES 表，这个表主要字段分别是：
TABLE_SCHEMA : 数据库名
TABLE_NAME：表名
ENGINE：所使用的存储引擎
TABLES_ROWS：记录数
DATA_LENGTH：数据大小
INDEX_LENGTH：索引大小
其他字段请参考MySQL的手册，我们只需要了解这几个就足够了。
所以要知道一个表占用空间的大小，那就相当于是 数据大小 + 索引大小 即可。
SQL:
SELECT TABLE_NAME,DATA_LENGTH+INDEX_LENGTH,TABLE_ROWS FROM TABLES WHERE TABLE_SCHEMA=&amp;lsquo;数据库名&amp;rsquo; AND TABLE_NAME=&amp;lsquo;表名&amp;rsquo;</description>
    </item>
    
    <item>
      <title>Unicode 编码 范围</title>
      <link>https://siskinc.github.io/post/unicode_%E7%BC%96%E7%A0%81_%E8%8C%83%E5%9B%B4/</link>
      <pubDate>Thu, 25 Jul 2019 17:33:08 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/unicode_%E7%BC%96%E7%A0%81_%E8%8C%83%E5%9B%B4/</guid>
      <description>文字部分
（ U+0000 – U+007F） 基本拉丁字符
（ U+0080 – U+00FF） 增补拉丁字符集 1
（ U+0100 – U+017F） 拉丁字符扩展集 A
（ U+0180 – U+024F） 拉丁字符扩展集 B
（ U+0370 – U+03FF） 希腊文字中的科普特字符
（ U+0370 – U+03FF） 希腊字符
（ U+0400 – U+04FF） 西里尔字符
（ U+0500 – U+052F） 增补西里尔字符
（ U+0530 – U+058F） 亚美尼亚字符
（ U+0590 – U+059F） 希伯来字符
（ U+0600 – U+06FF） 阿拉伯字符
（ U+0700 – U+074F） 叙利亚字符
（ U+0750 – U+077F） 增补阿拉伯字符
（ U+0780 – U+07BF） 塔纳字符</description>
    </item>
    
    <item>
      <title>gin mongodb restful api设计: 动态的patch接口</title>
      <link>https://siskinc.github.io/post/gin_mongodb_restful_api%E8%AE%BE%E8%AE%A1_%E5%8A%A8%E6%80%81%E7%9A%84patch%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Thu, 25 Jul 2019 17:31:19 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/gin_mongodb_restful_api%E8%AE%BE%E8%AE%A1_%E5%8A%A8%E6%80%81%E7%9A%84patch%E6%8E%A5%E5%8F%A3/</guid>
      <description>什么是Patch?   Patch方法可以用来更新资源的一个组成部分
 什么时候使用Patch?   当你仅需更新资源的某一项，即不完全也不幂等
 那当我们的模型在数据库中几乎每个字段都可能会遇到改变的时候，难道在patch的时候，或者专门写一个post的接口去一个一个if else操作吗，而我们又使用的是静态语言golang，有没有什么办法能够动态的让我们进行愉快的Patch呢？
答案当然是有的，先说说如何去实现：
  我们需要利用golang的map[string]interface{}结构
  我们需要一个动态的结构
  在mgo中大多使用map[string]interface{}的结构，我们直接构造出这个结构有利于我们直接进行Update({&amp;quot;$set&amp;quot;: xxxx})操作
    使用BindJSON函数，当然你也可以使用Gin的其他函数对map[string]interface{}进行绑定，这里我们不使用一个struct进行绑定，原因是我们无法判断客户端，或者说是浏览器会传送哪些字段来，这样做也有利于我们客户端将某一个字段置为默认值（如果用struct就只能避开默认值了）
  来，开始贴代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141  // 这个是我们需要存到数据库中的Model  type Article struct { ID bson.</description>
    </item>
    
    <item>
      <title>gin PostForm 方法不起作用</title>
      <link>https://siskinc.github.io/post/gin_postform_%E6%96%B9%E6%B3%95%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8/</link>
      <pubDate>Thu, 25 Jul 2019 17:30:08 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/gin_postform_%E6%96%B9%E6%B3%95%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8/</guid>
      <description>情景: 在httpie post 下，在 axios post下，总的来说，就是在form-data下只有c.Bind()会有用
如果一定要用c.PostForm() headers必须为x-www-form-urlencoded</description>
    </item>
    
    <item>
      <title>Django dumpdata and loaddata</title>
      <link>https://siskinc.github.io/post/django_dumpdata_and_loaddata/</link>
      <pubDate>Thu, 25 Jul 2019 17:29:18 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/django_dumpdata_and_loaddata/</guid>
      <description>原文来自于: https://coderwall.com/p/mvsoyg/django-dumpdata-and-loaddata
 dumpdata 命令  这个是Django自带的管理命令，可以用来备份你的模型实例和数据库  dumpdata 基本数据库的转存  下面的命令将把整个数据转存到db.json文件中   ./manage.py dumpdata &amp;gt; db.json
 dumpdata 备份特定的 app  下面的命令将在django admin app 转存到 admin.json文件中   ./manage.py dumpdata admin &amp;gt; admin.json
 dumpdata 备份特定的表  下面的命令将只转存django admin.logentry 表中的内容   ./manage.py dumpdata admin.logentry &amp;gt; logentry.json
  下面的命令将只转存django auth.user 表中的内容   ./manage.py dumpdata auth.user &amp;gt; user.json
 dumpdata (&amp;ndash;exclude)   你可以使用 &amp;ndash;exclude 选择不需要备份的app或者表</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 中不能声明为虚函数的函数有哪些？</title>
      <link>https://siskinc.github.io/post/cplusplus_%E4%B8%AD%E4%B8%8D%E8%83%BD%E5%A3%B0%E6%98%8E%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B/</link>
      <pubDate>Thu, 25 Jul 2019 17:03:49 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/cplusplus_%E4%B8%AD%E4%B8%8D%E8%83%BD%E5%A3%B0%E6%98%8E%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B/</guid>
      <description>普通函数  普通函数（非成员函数）只能被overload，不能被override，而且编译器会在编译时绑定函数。
 多态的运行期行为体现在虚函数上，虚函数通过继承方式来体现出多态作用，顶层函数不属于成员函数，是不能被继承的
构造函数  因为构造函数本来就是为了明确初始化对象成员才产生的，然而virtual function主要是为了在不完全了解细节的情况下也能正确处理对象。另外，virtual函数是在不同类型的对象产生不同的动作，现在对象还没有产生，如何使用virtual函数来完成你想完成的动作。
 内联成员函数  内联函数就是为了在代码中直接展开，减少函数调用花费的代价，虚函数是为了在继承后对象能够准确的执行自己的动作，这是不可能统一的。
 静态成员函数  静态成员函数对于每个类来说只有一份代码，所有的对象都共享这一份代码，他也没有要动态邦定的必要性。不能被继承，只属于该类。
 友元函数  C++不支持友元函数的继承，对于没有继承特性的函数没有虚函数的说法。友元函数不属于类的成员函数，不能被继承。
 </description>
    </item>
    
    <item>
      <title>C&#43;&#43; std::string 在一个字符串前插入一个字符串几种方式</title>
      <link>https://siskinc.github.io/post/cplusplus_stdstring_%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%89%8D%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Thu, 25 Jul 2019 17:03:24 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/cplusplus_stdstring_%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%89%8D%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</guid>
      <description>1、直接使用字符串相加 std::string a = &amp;quot;hello&amp;quot;;std::string b = &amp;quot;hello&amp;quot;;for(int i = 0; i &amp;lt; 100; ++i){a = b + a;}2、使用insert函数 std::string a = &amp;quot;hello&amp;quot;;for(int i = 0; i &amp;lt; 100; ++i){a.insert(0, &amp;quot;hello&amp;quot;);}比较：通过Quick C++ Benchmarks 可得到结果 static void StringCreation(benchmark::State&amp;amp; state) {// Code inside this loop is measured repeatedlystd::string x = &amp;quot;hello&amp;quot;;for (auto _ : state) {x.</description>
    </item>
    
    <item>
      <title>redis源码解读--动态字符串SDSHDR</title>
      <link>https://siskinc.github.io/post/redis%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2sdshdr/</link>
      <pubDate>Thu, 25 Jul 2019 16:54:31 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/redis%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2sdshdr/</guid>
      <description>阅读源码: sds.h sds.c
SDSHDR 全称 Simple Dynamic Strings Header
sds  char *的别名
 1 2 3  typedef char *sds;   sdshdr  sdshdr有好几个类别，它们分别是：sdshdr5，sdshdr8，sdshdr16，sdshdr32，sdshdr64，其中sdshdr5是不使用的
 源码如下：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61  /* Note: sdshdr5 is never used, we just access the flags byte directly.</description>
    </item>
    
    <item>
      <title>redis源码解读--内存分配zmalloc</title>
      <link>https://siskinc.github.io/post/redis%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8Dzmalloc/</link>
      <pubDate>Thu, 25 Jul 2019 16:52:10 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/redis%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8Dzmalloc/</guid>
      <description>主要函数   void *zmalloc(size_t size);
  void *zcalloc(size_t size);
  void *zrealloc(void *ptr, size_t size);
  void zfree(void *ptr);
  char *zstrdup(const char *s);
  size_t zmalloc_used_memory(void);
  void zmalloc_set_oom_handler(void (*oom_handler)(size_t));
  size_t zmalloc_get_rss(void);
  int zmalloc_get_allocator_info(size_t *allocated, size_t *active, size_t *resident);
  size_t zmalloc_get_private_dirty(long pid);
  size_t zmalloc_get_smap_bytes_by_field(char *field, long pid);
  size_t zmalloc_get_memory_size(void);
  void zlibc_free(void *ptr);</description>
    </item>
    
    <item>
      <title>vue 跨域问题</title>
      <link>https://siskinc.github.io/post/vue-%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</link>
      <pubDate>Thu, 25 Jul 2019 05:02:10 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/vue-%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</guid>
      <description>和后端联调时总是会面对恼人的跨域问题，最近基于Vue开发项目时也遇到了这个问题，两边各自想了一堆办法，查了一堆资料，加了一堆参数，最后还得我把自己的localhost映射成上线时将要使用的域名。
今天翻看代码时，突然发现vue-cli的config文件里有一个参数叫proxyTable，看这个名字就感觉能解决问题，于是我就去搜了一下，果然。在vuejs-templates，也就是vue-cli的使用的模板插件里，有关于API proxy的说明，使用的就是这个参数。
https://vuejs-templates.github.io/webpack/proxy.html
这个参数主要是一个地址映射表，你可以通过设置将复杂的url简化，例如我们要请求的地址是api.xxxxxxxx.com/list/1，可以按照如下设置：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  proxyTable: { &amp;#39;/list&amp;#39;: { target: &amp;#39;http://api.xxxxxxxx.com&amp;#39;, pathRewrite: { &amp;#39;^/list&amp;#39;: &amp;#39;/list&amp;#39; } } }   这样我们在写url的时候，只用写成/list/1就可以代表api.xxxxxxxx.com/list/1.
那么又是如何解决跨域问题的呢？其实在上面的list的参数里有一个changeOrigin参数，接收一个布尔值，如果设置为true,那么本地会虚拟一个服务端接收你的请求并代你发送该请求，这样就不会有跨域问题了，当然这只适用于开发环境。增加的代码如下所示：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  proxyTable: { &amp;#39;/list&amp;#39;: { target: &amp;#39;http://api.xxxxxxxx.com&amp;#39;, changeOrigin: true, pathRewrite: { &amp;#39;^/list&amp;#39;: &amp;#39;/list&amp;#39; } } }   </description>
    </item>
    
    <item>
      <title>axios_发送post请求</title>
      <link>https://siskinc.github.io/post/axios-%E5%8F%91%E9%80%81post%E8%AF%B7%E6%B1%82/</link>
      <pubDate>Thu, 25 Jul 2019 05:01:19 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/axios-%E5%8F%91%E9%80%81post%E8%AF%B7%E6%B1%82/</guid>
      <description>方案一 在node中使用axios以post的方式发送一张图片给某个server时:
let data = fs.createReadStream(__dirname + &#39;/test.jpg&#39;)axios.post(url,{media:data,type:&amp;quot;image&amp;quot;}).then(function (response) {console.log(response.data);}).catch(function (error) {console.log(error);})方案二 事实证明，这样做是完全没有用的，我尝试向另一个服务器poststream，返回的总是错误。然而，如果我使用request，下面这样的代码是完全没有问题的：
let data = fs.createReadStream(__dirname + &#39;/test.jpg&#39;)let form = {type:&amp;quot;image&amp;quot;,media:data}request.post({url:url,formData:form},(err,res,body)=&amp;gt;{if(err) console.log(err)console.log(body)})// 注册事件方法register: function() {let registerUrl = this.GetServerUrl() + &amp;quot;/user/signup&amp;quot;;let params = {username: this.username,password: this.password,email: this.email,captcha: this.captcha};this.axios.post(registerUrl, params).then(response =&amp;gt; {if(response.</description>
    </item>
    
    <item>
      <title>Error_inflating_class_fragment</title>
      <link>https://siskinc.github.io/post/error-inflating-class-fragment/</link>
      <pubDate>Thu, 25 Jul 2019 04:53:44 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/error-inflating-class-fragment/</guid>
      <description>如果你的 XXXXFragment 从android.app.Fragment继承，你需要改变一下onCreateView()方法。return你需要显示Fragment view或者转换使用LayoutInflater转换你的布局变成view，并return 他。
1 2 3 4 5 6 7 8 9 10 11  @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { View mainview = inflater.inflate(R.layout.main, null); return mainview; }   </description>
    </item>
    
    <item>
      <title>redis_mongodb持久化的方式</title>
      <link>https://siskinc.github.io/post/redis-mongodb%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Thu, 25 Jul 2019 04:36:53 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/redis-mongodb%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E6%96%B9%E5%BC%8F/</guid>
      <description>redis持久化方式(两种) RDB持久化 redis提供了RDB持久化的功能，这个功能可以将redis在内存中的的状态保存到硬盘中，相当于snapshot，它可以手动执行，也可以再redis.conf中配置，定期执行。
相关配置   databases
配置db文件的数目，可以用select dbid 指令为每个连接指定后续持久化时的db文件，新连接默认均使用db 0
  save
SNAPSHOTTING的持久化方式有多种save策略可供选择，而且支持混用，例如：
save 900 1
save 300 100
save 60 10000
上述配置的效果是：snapshotting会在3个条件中的任何一个满足时被触发：
  900s内至少1个key有变化；
  300s内至少100个key有变化；
  60s内至少有10000个key有变化
  save条件被触发时，Redis通过fork子进程，由子进程在后台实现异步dump磁盘。根据fork的写时复制策略，若持久化过程中出现很多写入请求，在最坏的情况下，需要的内存是当前数据集所占内存的2倍。
备注1：上述配置的3个触发条件其实是逐次加强的，哪个条件先满足就先触发那个save策略。
备注2：如果业务不需要持久化或不需要RDB方式的持久化，可以通过注释掉save配置项来实现
  stop-writes-on-bgsave-error
指定Redis在后台dump磁盘出错时的行为，默认为yes，表示若后台dump出错，则RedisServer拒绝新的写入请求，通过这种方式来引起用户警觉，避免因用户未发现异常而引起更大的事故。
  rdbcompression
RDB文件是否压缩存储，若为yes，会在压缩时消耗一点CPU，但省磁盘空间。
  rdbchecksum
RDB文件是否需要CRC64校验, 若为yes,会在生成RDB文件后计算其CRC64并将结果追加至文件尾，同样，Redis启动Load RDB时，也会先计算该文件的CRC64并与dump时的计算结果对比。
   好处：可以严格保证RDB的完整性及安全性
 代价：会在dump或load时损失10%的性能。如果要最大化Redis的性能，这个配置项应该用no关掉
 dbfilename
指定RDB文件名，默认为dump.rdb
  dir
指定RDB文件存放目录的路径，若包含多级路径，则相关父路径需事先mkdir出来，否则启动失败。
  AOF持久化 AOF持久化（Append-Only-File），与RDB持久化不同，AOF持久化是通过保存Redis服务器锁执行的写状态来记录数据库的，即commandlog。</description>
    </item>
    
  </channel>
</rss>
