<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>convert on Daryl&#39;s Blog</title>
    <link>https://siskinc.github.io/tags/convert/</link>
    <description>Recent content in convert on Daryl&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 17 Dec 2019 19:36:31 +0000</lastBuildDate><atom:link href="https://siskinc.github.io/tags/convert/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>golang scan rows to []string，golang使用mysql，将结果写入到string列表中</title>
      <link>https://siskinc.github.io/post/golang_scan_rows_to_stringgolang%E4%BD%BF%E7%94%A8mysql%E5%B0%86%E7%BB%93%E6%9E%9C%E5%86%99%E5%85%A5%E5%88%B0string%E5%88%97%E8%A1%A8%E4%B8%AD/</link>
      <pubDate>Tue, 17 Dec 2019 19:36:31 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/golang_scan_rows_to_stringgolang%E4%BD%BF%E7%94%A8mysql%E5%B0%86%E7%BB%93%E6%9E%9C%E5%86%99%E5%85%A5%E5%88%B0string%E5%88%97%E8%A1%A8%E4%B8%AD/</guid>
      <description>rows, err := db.Query(sqlStr) if err != nil { return } for rows.Next() { result := make([]string, len(readerResult.Columns)) pointers := make([]interface{}, len(result)) for i := range pointers { pointers[i] = &amp;amp;result[i] } err := rows.Scan(pointers...) if err != nil { logrus.Fatalf(&amp;#34;scan have an err: %v, sql string: %s&amp;#34;, err, sqlStr) } } </description>
    </item>
    
    <item>
      <title>Golang不会自动把slice转换成interface{}类型的slice</title>
      <link>https://siskinc.github.io/post/golang%E4%B8%8D%E4%BC%9A%E8%87%AA%E5%8A%A8%E6%8A%8Aslice%E8%BD%AC%E6%8D%A2%E6%88%90interface%E7%B1%BB%E5%9E%8B%E7%9A%84slice/</link>
      <pubDate>Thu, 25 Jul 2019 17:46:17 +0000</pubDate>
      
      <guid>https://siskinc.github.io/post/golang%E4%B8%8D%E4%BC%9A%E8%87%AA%E5%8A%A8%E6%8A%8Aslice%E8%BD%AC%E6%8D%A2%E6%88%90interface%E7%B1%BB%E5%9E%8B%E7%9A%84slice/</guid>
      <description>例子 我们时常会写一些interface，例如：
type A interface{ Print() } type B struct { } func (b *B) Print() { fmt.Println(&amp;#34;Here is *B&amp;#34;) } 赋值的时候:
var a A a = &amp;amp;B{} 诶，这样看视乎没什么问题，但是我们没有办法避免使用数组，然后顺手就写了这样的代码
var aa []A aa = make([]*B, 10) 好的，现在翻车了，会得到一个这样的报错：
cannot use make([]*B, 10) (type []*B) as type []A in assignment原因   []A 不是一个interface，它只是一个slice，并且刚刚好元素类型是A。
  []A 有自己特殊的内存分布，每一个interface{}有两个字节，一个是存储他是什么类型，另一个存储数据或者指针来指向他。因此，一个[]A是一块N*2的数据，但是[]*B是一块N*(sizeof(*B))的数据。
  如何去实现 bb := []*B{&amp;amp;B{}, &amp;amp;B{}} var aa []AA = make([]AA, len(bb)) for i, d := range bb { aa[i] = d } </description>
    </item>
    
  </channel>
</rss>
