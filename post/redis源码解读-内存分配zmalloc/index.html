<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.81.0-DEV" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>redis源码解读--内存分配zmalloc &middot; Daryl&#39;s Blog</title>
  <meta name="description" content="" />

  
  <link type="text/css" rel="stylesheet" href="http://siskinc.github.io/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="http://siskinc.github.io/css/poole.css">
  <link type="text/css" rel="stylesheet" href="http://siskinc.github.io/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="http://siskinc.github.io/css/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  
</head>

  <body class=" ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="http://siskinc.github.io/"><h1>Daryl&#39;s Blog</h1></a>
      <p class="lead">
      An elegant open source and mobile first theme for <a href="http://hugo.spf13.com">hugo</a> made by <a href="http://twitter.com/mdo">@mdo</a>. Originally made for Jekyll.
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li><a href="http://siskinc.github.io/">Home</a> </li>
        
      </ul>
    </nav>

    <p>&copy; 2021. All rights reserved. </p>
  </div>
</aside>

    <main class="content container">
    <div class="post">
  <h1>redis源码解读--内存分配zmalloc</h1>
  <time datetime=2019-07-25T16:52:10Z class="post-date">Thu, Jul 25, 2019</time>
  <p>[TOC]</p>
<h2 id="主要函数">主要函数</h2>
<ul>
<li>
<p>void *zmalloc(size_t size);</p>
</li>
<li>
<p>void *zcalloc(size_t size);</p>
</li>
<li>
<p>void *zrealloc(void *ptr, size_t size);</p>
</li>
<li>
<p>void zfree(void *ptr);</p>
</li>
<li>
<p>char *zstrdup(const char *s);</p>
</li>
<li>
<p>size_t zmalloc_used_memory(void);</p>
</li>
<li>
<p>void zmalloc_set_oom_handler(void (*oom_handler)(size_t));</p>
</li>
<li>
<p>size_t zmalloc_get_rss(void);</p>
</li>
<li>
<p>int zmalloc_get_allocator_info(size_t *allocated, size_t *active, size_t *resident);</p>
</li>
<li>
<p>size_t zmalloc_get_private_dirty(long pid);</p>
</li>
<li>
<p>size_t zmalloc_get_smap_bytes_by_field(char *field, long pid);</p>
</li>
<li>
<p>size_t zmalloc_get_memory_size(void);</p>
</li>
<li>
<p>void zlibc_free(void *ptr);</p>
</li>
</ul>
<h2 id="void-zmallocsize_t-size">void *zmalloc(size_t size)</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">zmalloc</span>(size_t size) {

    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>ptr <span style="color:#f92672">=</span> malloc(size<span style="color:#f92672">+</span>PREFIX_SIZE);



    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>ptr) zmalloc_oom_handler(size);

<span style="color:#75715e">#ifdef HAVE_MALLOC_SIZE
</span><span style="color:#75715e"></span>
    update_zmalloc_stat_alloc(zmalloc_size(ptr));

    <span style="color:#66d9ef">return</span> ptr;

<span style="color:#75715e">#else
</span><span style="color:#75715e"></span>
    <span style="color:#f92672">*</span>((size_t<span style="color:#f92672">*</span>)ptr) <span style="color:#f92672">=</span> size;

    update_zmalloc_stat_alloc(size<span style="color:#f92672">+</span>PREFIX_SIZE);

    <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)ptr<span style="color:#f92672">+</span>PREFIX_SIZE;

<span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>
}

</code></pre></div><blockquote>
<p>参数size是需要分配的空间大小。事实上我们需要分配的空间大小为size+PREFIX_SIZE。PREFIX_SIZE是根据平台的不同和HAVE_MALLOC_SIZE宏定义控制的。如果malloc()函数调用失败，就会调用zmalloc_oom_handler()函数来打印异常，并且会终止函数，zmalloc_oom_handler其实是一个函数指针，真正调用的函数是zmalloc_default_oom(),zmalloc_default_oom()函数源码如下:</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">zmalloc_default_oom</span>(size_t size) {

    fprintf(stderr, <span style="color:#f92672">&amp;</span>quot;zmalloc: Out of memory trying to allocate <span style="color:#f92672">%</span>zu bytes<span style="color:#960050;background-color:#1e0010">\</span>n<span style="color:#f92672">&amp;</span>quot;,

        size);

    fflush(stderr);

    abort();

}



<span style="color:#66d9ef">static</span> <span style="color:#a6e22e">void</span> (<span style="color:#f92672">*</span>zmalloc_oom_handler)(size_t) <span style="color:#f92672">=</span> zmalloc_default_oom;

</code></pre></div><blockquote>
<p>内存分配成功之后，会依据HAVE_MALLOC_SIZE的控制对前八个字节操作，用以记录分配内存的长度，会在update_zmalloc_stat_alloc()宏定义函数中更新used_memory这个静态变量的值，update_zmalloc_stat_alloc()源码如下:</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#define update_zmalloc_stat_alloc(__n) do { \
</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    size_t _n <span style="color:#f92672">=</span> (__n); \

    <span style="color:#66d9ef">if</span> (_n<span style="color:#f92672">&amp;</span>amp;(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">long</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)) _n <span style="color:#f92672">+=</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">long</span>)<span style="color:#f92672">-</span>(_n<span style="color:#f92672">&amp;</span>amp;(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">long</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)); \

    atomicIncr(used_memory,__n); \

} <span style="color:#66d9ef">while</span>(<span style="color:#ae81ff">0</span>)

</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">if</span> (_n<span style="color:#f92672">&amp;</span>amp;(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">long</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)) _n <span style="color:#f92672">+=</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">long</span>)<span style="color:#f92672">-</span>(_n<span style="color:#f92672">&amp;</span>amp;(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">long</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>));

</code></pre></div><blockquote>
<p>这一行是为了将不为sizeof(long)的_n对sizeof(long)补齐  
atomicIncr(used_memory,__n);会调用__atomic_add_fetch(&amp;var,(count),__ATOMIC_RELAXED);用于保证更新used_memory变量的操作是一个原子操作。</p>
</blockquote>
<h2 id="void-zcallocsize_t-size">void *zcalloc(size_t size)</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">zcalloc</span>(size_t size) {

    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>ptr <span style="color:#f92672">=</span> calloc(<span style="color:#ae81ff">1</span>, size<span style="color:#f92672">+</span>PREFIX_SIZE);



    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>ptr) zmalloc_oom_handler(size);

<span style="color:#75715e">#ifdef HAVE_MALLOC_SIZE
</span><span style="color:#75715e"></span>
    update_zmalloc_stat_alloc(zmalloc_size(ptr));

    <span style="color:#66d9ef">return</span> ptr;

<span style="color:#75715e">#else
</span><span style="color:#75715e"></span>
    <span style="color:#f92672">*</span>((size_t<span style="color:#f92672">*</span>)ptr) <span style="color:#f92672">=</span> size;

    update_zmalloc_stat_alloc(size<span style="color:#f92672">+</span>PREFIX_SIZE);

    <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)ptr<span style="color:#f92672">+</span>PREFIX_SIZE;

<span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>
}

</code></pre></div><blockquote>
<p>zcalloc函数和zmalloc函数处理的思路很是相似，就不做太多的解释了</p>
</blockquote>
<h2 id="void-zreallocvoid-ptr-size_t-size">void *zrealloc(void *ptr, size_t size)</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">zrealloc</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>ptr, size_t size) {

    <span style="color:#75715e">// 如果没有定义HAVE_MALLOC_SIZE，就说明PREFIX_SIZE宏定义不为0，那么ptr并不是该段内存真正的开始地址
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#ifndef HAVE_MALLOC_SIZE
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>realptr;

<span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>
    size_t oldsize;

    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>newptr;



    <span style="color:#66d9ef">if</span> (ptr <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span> zmalloc(size);

<span style="color:#75715e">// 根据HAVE_MALLOC_SIZE宏定义，oldsize,newptr获取方式不一样，以及更新used_memory的细节
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#ifdef HAVE_MALLOC_SIZE
</span><span style="color:#75715e"></span>
    oldsize <span style="color:#f92672">=</span> zmalloc_size(ptr);

    newptr <span style="color:#f92672">=</span> realloc(ptr,size);

    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>newptr) zmalloc_oom_handler(size);



    update_zmalloc_stat_free(oldsize);

    update_zmalloc_stat_alloc(zmalloc_size(newptr));

    <span style="color:#66d9ef">return</span> newptr;

<span style="color:#75715e">#else
</span><span style="color:#75715e"></span>
    realptr <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)ptr<span style="color:#f92672">-</span>PREFIX_SIZE;

    oldsize <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>((size_t<span style="color:#f92672">*</span>)realptr);

    newptr <span style="color:#f92672">=</span> realloc(realptr,size<span style="color:#f92672">+</span>PREFIX_SIZE);

    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>newptr) zmalloc_oom_handler(size);



    <span style="color:#f92672">*</span>((size_t<span style="color:#f92672">*</span>)newptr) <span style="color:#f92672">=</span> size;

    update_zmalloc_stat_free(oldsize<span style="color:#f92672">+</span>PREFIX_SIZE);

    update_zmalloc_stat_alloc(size<span style="color:#f92672">+</span>PREFIX_SIZE);

    <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)newptr<span style="color:#f92672">+</span>PREFIX_SIZE;

<span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>
}

</code></pre></div><blockquote>
<p>大致思路就是根据新的size进行重新分配内存，并且对used_memory变量进行更新。只不过获取原内存大小方式不一样，根据HAVE_MALLOC_SIZE进行区分。</p>
</blockquote>
<h2 id="void-zfreevoid-ptr">void zfree(void *ptr)</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">zfree</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>ptr) {

<span style="color:#75715e">#ifndef HAVE_MALLOC_SIZE
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>realptr;

    size_t oldsize;

<span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>


    <span style="color:#66d9ef">if</span> (ptr <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span>;

<span style="color:#75715e">#ifdef HAVE_MALLOC_SIZE
</span><span style="color:#75715e"></span>
    update_zmalloc_stat_free(zmalloc_size(ptr));

    free(ptr);

<span style="color:#75715e">#else
</span><span style="color:#75715e"></span>
    realptr <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)ptr<span style="color:#f92672">-</span>PREFIX_SIZE;

    oldsize <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>((size_t<span style="color:#f92672">*</span>)realptr);

    update_zmalloc_stat_free(oldsize<span style="color:#f92672">+</span>PREFIX_SIZE);

    free(realptr);

<span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>
}

</code></pre></div><blockquote>
<p>其实zfree函数和zrealloc函数做法差不到太多，都是对oldsize和realptr对HAVE_MALLOC_SIZE有无声明分别进行操作。</p>
</blockquote>
<h2 id="char-zstrdupconst-char-s">char *zstrdup(const char *s)</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">zstrdup</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>s) {

    size_t l <span style="color:#f92672">=</span> strlen(s)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;

    <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> zmalloc(l);



    memcpy(p,s,l);

    <span style="color:#66d9ef">return</span> p;

}

</code></pre></div><blockquote>
<p>该函数是创建一个字符串副本</p>
</blockquote>
<h2 id="size_t-zmalloc_used_memoryvoid">size_t zmalloc_used_memory(void)</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">size_t <span style="color:#a6e22e">zmalloc_used_memory</span>(<span style="color:#66d9ef">void</span>) {

    size_t um;

    atomicGet(used_memory,um);

    <span style="color:#66d9ef">return</span> um;

}

</code></pre></div><blockquote>
<p>获取used_memory变量的值，主要保证原子操作(在atomicGet(used_memory,um);中保证)</p>
</blockquote>
<h2 id="void-zmalloc_set_oom_handlervoid-oom_handlersize_t">void zmalloc_set_oom_handler(void (*oom_handler)(size_t))</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">zmalloc_set_oom_handler</span>(<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>oom_handler)(size_t)) {

    zmalloc_oom_handler <span style="color:#f92672">=</span> oom_handler;

}

</code></pre></div><blockquote>
<p>主要用来设置内存分配失败处理函数指针zmalloc_oom_handler的值</p>
</blockquote>
<h2 id="size_t-zmalloc_get_rssvoid">size_t zmalloc_get_rss(void)</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">size_t <span style="color:#a6e22e">zmalloc_get_rss</span>(<span style="color:#66d9ef">void</span>) {

    <span style="color:#66d9ef">int</span> page <span style="color:#f92672">=</span> sysconf(_SC_PAGESIZE);

    size_t rss;

    <span style="color:#66d9ef">char</span> buf[<span style="color:#ae81ff">4096</span>];

    <span style="color:#66d9ef">char</span> filename[<span style="color:#ae81ff">256</span>];

    <span style="color:#66d9ef">int</span> fd, count;

    <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>p, <span style="color:#f92672">*</span>x;



    snprintf(filename,<span style="color:#ae81ff">256</span>,<span style="color:#f92672">&amp;</span>quot;<span style="color:#f92672">/</span>proc<span style="color:#f92672">/%</span>d<span style="color:#f92672">/</span>stat<span style="color:#f92672">&amp;</span>quot;,getpid());

    <span style="color:#66d9ef">if</span> ((fd <span style="color:#f92672">=</span> open(filename,O_RDONLY)) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;

    <span style="color:#66d9ef">if</span> (read(fd,buf,<span style="color:#ae81ff">4096</span>) <span style="color:#f92672">&amp;</span>lt;<span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) {

        close(fd);

        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;

    }

    close(fd);



    p <span style="color:#f92672">=</span> buf;

    count <span style="color:#f92672">=</span> <span style="color:#ae81ff">23</span>; <span style="color:#75715e">/* RSS is the 24th field in /proc/&amp;lt;pid&amp;gt;/stat */</span>

    <span style="color:#66d9ef">while</span>(p <span style="color:#f92672">&amp;</span>amp;<span style="color:#f92672">&amp;</span>amp; count<span style="color:#f92672">--</span>) {

        p <span style="color:#f92672">=</span> strchr(p,<span style="color:#f92672">&amp;</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">03</span><span style="color:#ae81ff">9</span>; <span style="color:#f92672">&amp;</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">03</span><span style="color:#ae81ff">9</span>;);

        <span style="color:#66d9ef">if</span> (p) p<span style="color:#f92672">++</span>;

    }

    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>p) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;

    x <span style="color:#f92672">=</span> strchr(p,<span style="color:#f92672">&amp;</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">03</span><span style="color:#ae81ff">9</span>; <span style="color:#f92672">&amp;</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">03</span><span style="color:#ae81ff">9</span>;);

    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>x) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;

    <span style="color:#f92672">*</span>x <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">03</span><span style="color:#ae81ff">9</span>;<span style="color:#960050;background-color:#1e0010">\</span><span style="color:#ae81ff">0</span><span style="color:#f92672">&amp;</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">03</span><span style="color:#ae81ff">9</span>;;



    rss <span style="color:#f92672">=</span> strtoll(p,NULL,<span style="color:#ae81ff">10</span>);

    rss <span style="color:#f92672">*=</span> page;

    <span style="color:#66d9ef">return</span> rss;

}

</code></pre></div><blockquote>
<p>返回驻留集大小</p>
</blockquote>
<h2 id="int-zmalloc_get_allocator_infosize_t-allocated-size_t-active-size_t-resident">int zmalloc_get_allocator_info(size_t *allocated, size_t *active, size_t *resident)</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#if defined(USE_JEMALLOC)
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">zmalloc_get_allocator_info</span>(size_t <span style="color:#f92672">*</span>allocated,

                               size_t <span style="color:#f92672">*</span>active,

                               size_t <span style="color:#f92672">*</span>resident) {

    uint64_t epoch <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;

    size_t sz;

    <span style="color:#f92672">*</span>allocated <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>resident <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>active <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

    <span style="color:#75715e">/* Update the statistics cached by mallctl. */</span>

    sz <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(epoch);

    je_mallctl(<span style="color:#f92672">&amp;</span>quot;epoch<span style="color:#f92672">&amp;</span>quot;, <span style="color:#f92672">&amp;</span>amp;epoch, <span style="color:#f92672">&amp;</span>amp;sz, <span style="color:#f92672">&amp;</span>amp;epoch, sz);

    sz <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(size_t);

    <span style="color:#75715e">/* Unlike RSS, this does not include RSS from shared libraries and other non
</span><span style="color:#75715e">
</span><span style="color:#75715e">     * heap mappings. */</span>

    je_mallctl(<span style="color:#f92672">&amp;</span>quot;stats.resident<span style="color:#f92672">&amp;</span>quot;, resident, <span style="color:#f92672">&amp;</span>amp;sz, NULL, <span style="color:#ae81ff">0</span>);

    <span style="color:#75715e">/* Unlike resident, this doesn&amp;#039;t not include the pages jemalloc reserves
</span><span style="color:#75715e">
</span><span style="color:#75715e">     * for re-use (purge will clean that). */</span>

    je_mallctl(<span style="color:#f92672">&amp;</span>quot;stats.active<span style="color:#f92672">&amp;</span>quot;, active, <span style="color:#f92672">&amp;</span>amp;sz, NULL, <span style="color:#ae81ff">0</span>);

    <span style="color:#75715e">/* Unlike zmalloc_used_memory, this matches the stats.resident by taking
</span><span style="color:#75715e">
</span><span style="color:#75715e">     * into account all allocations done by this process (not only zmalloc). */</span>

    je_mallctl(<span style="color:#f92672">&amp;</span>quot;stats.allocated<span style="color:#f92672">&amp;</span>quot;, allocated, <span style="color:#f92672">&amp;</span>amp;sz, NULL, <span style="color:#ae81ff">0</span>);

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;

}

<span style="color:#75715e">#else
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">zmalloc_get_allocator_info</span>(size_t <span style="color:#f92672">*</span>allocated,

                               size_t <span style="color:#f92672">*</span>active,

                               size_t <span style="color:#f92672">*</span>resident) {

    <span style="color:#f92672">*</span>allocated <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>resident <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>active <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;

}

<span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>
</code></pre></div><blockquote>
<p>获取分配器的信息，主要在使用jemalloc前提下使用，获取jemalloc分配的信息，详细信息可在<a href="http://jemalloc.net/jemalloc.3.html">http://jemalloc.net/jemalloc.3.html</a>查阅</p>
</blockquote>
<h2 id="size_t-zmalloc_get_smap_bytes_by_fieldchar-field-long-pid">size_t zmalloc_get_smap_bytes_by_field(char *field, long pid)</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#if defined(HAVE_PROC_SMAPS)
</span><span style="color:#75715e"></span>
size_t <span style="color:#a6e22e">zmalloc_get_smap_bytes_by_field</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>field, <span style="color:#66d9ef">long</span> pid) {

    <span style="color:#66d9ef">char</span> line[<span style="color:#ae81ff">1024</span>];

    size_t bytes <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

    <span style="color:#66d9ef">int</span> flen <span style="color:#f92672">=</span> strlen(field);

    FILE <span style="color:#f92672">*</span>fp;



    <span style="color:#66d9ef">if</span> (pid <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {

        <span style="color:#75715e">// /proc/pid/smaps反应了运行时的进程的内存影响，系统的运行时库(so)，堆，栈信息均可在其中看到。
</span><span style="color:#75715e"></span>
        fp <span style="color:#f92672">=</span> fopen(<span style="color:#f92672">&amp;</span>quot;<span style="color:#f92672">/</span>proc<span style="color:#f92672">/</span>self<span style="color:#f92672">/</span>smaps<span style="color:#f92672">&amp;</span>quot;,<span style="color:#f92672">&amp;</span>quot;r<span style="color:#f92672">&amp;</span>quot;);

    } <span style="color:#66d9ef">else</span> {

        <span style="color:#66d9ef">char</span> filename[<span style="color:#ae81ff">128</span>];

        snprintf(filename,<span style="color:#66d9ef">sizeof</span>(filename),<span style="color:#f92672">&amp;</span>quot;<span style="color:#f92672">/</span>proc<span style="color:#f92672">/%</span>ld<span style="color:#f92672">/</span>smaps<span style="color:#f92672">&amp;</span>quot;,pid);

        fp <span style="color:#f92672">=</span> fopen(filename,<span style="color:#f92672">&amp;</span>quot;r<span style="color:#f92672">&amp;</span>quot;);

    }



    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>fp) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;

    <span style="color:#66d9ef">while</span>(fgets(line,<span style="color:#66d9ef">sizeof</span>(line),fp) <span style="color:#f92672">!=</span> NULL) {

        <span style="color:#66d9ef">if</span> (strncmp(line,field,flen) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {

            <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> strchr(line,<span style="color:#f92672">&amp;</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">03</span><span style="color:#ae81ff">9</span>;k<span style="color:#f92672">&amp;</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">03</span><span style="color:#ae81ff">9</span>;);

            <span style="color:#66d9ef">if</span> (p) {

                <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">03</span><span style="color:#ae81ff">9</span>;<span style="color:#960050;background-color:#1e0010">\</span><span style="color:#ae81ff">0</span><span style="color:#f92672">&amp;</span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">03</span><span style="color:#ae81ff">9</span>;;

                bytes <span style="color:#f92672">+=</span> strtol(line<span style="color:#f92672">+</span>flen,NULL,<span style="color:#ae81ff">10</span>) <span style="color:#f92672">*</span> <span style="color:#ae81ff">1024</span>;

            }

        }

    }

    fclose(fp);

    <span style="color:#66d9ef">return</span> bytes;

}

<span style="color:#75715e">#else
</span><span style="color:#75715e"></span>
size_t <span style="color:#a6e22e">zmalloc_get_smap_bytes_by_field</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>field, <span style="color:#66d9ef">long</span> pid) {

    ((<span style="color:#66d9ef">void</span>) field);

    ((<span style="color:#66d9ef">void</span>) pid);

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;

}

<span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>
</code></pre></div><blockquote>
<p>获取/proc/pid/smaps中某一个field的字节大小</p>
</blockquote>
<h2 id="size_t-zmalloc_get_private_dirtylong-pid">size_t zmalloc_get_private_dirty(long pid)</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">size_t <span style="color:#a6e22e">zmalloc_get_private_dirty</span>(<span style="color:#66d9ef">long</span> pid) {

    <span style="color:#66d9ef">return</span> zmalloc_get_smap_bytes_by_field(<span style="color:#f92672">&amp;</span>quot;Private_Dirty:<span style="color:#f92672">&amp;</span>quot;,pid);

}

</code></pre></div><blockquote>
<p>获取Rss中已改写的私有页面页面大小</p>
</blockquote>
<h2 id="size_t-zmalloc_get_memory_sizevoid">size_t zmalloc_get_memory_size(void)</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">size_t <span style="color:#a6e22e">zmalloc_get_memory_size</span>(<span style="color:#66d9ef">void</span>) {

<span style="color:#75715e">#if defined(__unix__) || defined(__unix) || defined(unix) || \
</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>    (defined(__APPLE__) <span style="color:#f92672">&amp;</span>amp;<span style="color:#f92672">&amp;</span>amp; defined(__MACH__))

<span style="color:#75715e">#if defined(CTL_HW) &amp;amp;&amp;amp; (defined(HW_MEMSIZE) || defined(HW_PHYSMEM64))
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">int</span> mib[<span style="color:#ae81ff">2</span>];

    mib[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> CTL_HW;

<span style="color:#75715e">#if defined(HW_MEMSIZE)
</span><span style="color:#75715e"></span>
    mib[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> HW_MEMSIZE;            <span style="color:#75715e">/* OSX. --------------------- */</span>

<span style="color:#75715e">#elif defined(HW_PHYSMEM64)
</span><span style="color:#75715e"></span>
    mib[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> HW_PHYSMEM64;          <span style="color:#75715e">/* NetBSD, OpenBSD. --------- */</span>

<span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>
    int64_t size <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;               <span style="color:#75715e">/* 64-bit */</span>

    size_t len <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(size);

    <span style="color:#66d9ef">if</span> (sysctl( mib, <span style="color:#ae81ff">2</span>, <span style="color:#f92672">&amp;</span>amp;size, <span style="color:#f92672">&amp;</span>amp;len, NULL, <span style="color:#ae81ff">0</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)

        <span style="color:#66d9ef">return</span> (size_t)size;

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0L</span>;          <span style="color:#75715e">/* Failed? */</span>



<span style="color:#75715e">#elif defined(_SC_PHYS_PAGES) &amp;amp;&amp;amp; defined(_SC_PAGESIZE)
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">/* FreeBSD, Linux, OpenBSD, and Solaris. -------------------- */</span>

    <span style="color:#66d9ef">return</span> (size_t)sysconf(_SC_PHYS_PAGES) <span style="color:#f92672">*</span> (size_t)sysconf(_SC_PAGESIZE);



<span style="color:#75715e">#elif defined(CTL_HW) &amp;amp;&amp;amp; (defined(HW_PHYSMEM) || defined(HW_REALMEM))
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">/* DragonFly BSD, FreeBSD, NetBSD, OpenBSD, and OSX. -------- */</span>

    <span style="color:#66d9ef">int</span> mib[<span style="color:#ae81ff">2</span>];

    mib[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> CTL_HW;

<span style="color:#75715e">#if defined(HW_REALMEM)
</span><span style="color:#75715e"></span>
    mib[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> HW_REALMEM;        <span style="color:#75715e">/* FreeBSD. ----------------- */</span>

<span style="color:#75715e">#elif defined(HW_PHYSMEM)
</span><span style="color:#75715e"></span>
    mib[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> HW_PHYSMEM;        <span style="color:#75715e">/* Others. ------------------ */</span>

<span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> size <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;      <span style="color:#75715e">/* 32-bit */</span>

    size_t len <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(size);

    <span style="color:#66d9ef">if</span> (sysctl(mib, <span style="color:#ae81ff">2</span>, <span style="color:#f92672">&amp;</span>amp;size, <span style="color:#f92672">&amp;</span>amp;len, NULL, <span style="color:#ae81ff">0</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)

        <span style="color:#66d9ef">return</span> (size_t)size;

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0L</span>;          <span style="color:#75715e">/* Failed? */</span>

<span style="color:#75715e">#else
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0L</span>;          <span style="color:#75715e">/* Unknown method to get the data. */</span>

<span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#else
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0L</span>;          <span style="color:#75715e">/* Unknown OS. */</span>

<span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>
}

</code></pre></div><blockquote>
<p>获取物理内存的字节数</p>
</blockquote>
<h2 id="总结">总结</h2>
<blockquote>
<p>看了redis内存分配的源码后，其实没有相信中的那么难以理解，或许只是心理上的作用，当然也说明redis源码写得真的是好，让我这种渣渣都能轻而易举的看懂，并且注释也很少，这里的函数几乎都是对glibc的malloc中的函数进行了一层包装，并且维护了一个叫做used_memory的全局变量，并且每一次对全局变量的操作都是<strong>原子操作</strong>。也对一些常用的函数进行了封装，例如：获取rss的大小，获取/proc/pid/smaps文件中某一field占用字节数的大小，获取物理内存字节数等等，总的来说，收益匪浅，没想到内存操作可以做到这样简单。</p>
</blockquote>

</div>


    </main>

    
      
    
  </body>
</html>
